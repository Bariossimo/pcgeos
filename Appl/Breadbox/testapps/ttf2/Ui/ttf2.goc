/********************************************************************
 *
 *	Testapp f√ºr das Rendern von TTF-Fonts
 *
 *******************************************************************/
@include <stdapp.goh>
#include <geos.h>
#include <stdlib.h>
#include "FreeType/freetype.h"


#define FONT_SIZE 16

TT_Engine   engine;
TT_Face     face;


@class TtfProcessClass, GenProcessClass;
@endc;
@classdecl TtfProcessClass, neverSaved;

/********************************************************************
 *		UI Object Resources
 *******************************************************************/
@start AppResource;

@object GenApplicationClass TtfApp = {
    GI_visMoniker = list { @TtfTextMoniker };
    GI_comp = @TtfPrimary;

    gcnList( MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS ) = @TtfPrimary;
}

@visMoniker TtfTextMoniker = "TTF Test";

@end AppResource;


@start Interface;

@object GenPrimaryClass TtfPrimary  = {
    GI_comp = @TtfView,
              @LogText;
    ATTR_GEN_DISPLAY_NOT_MINIMIZABLE;
    HINT_ORIENT_CHILDREN_HORIZONTALLY;
}

@object GenViewClass TtfView = {
    GVI_horizAttrs = @default | GVDA_SCROLLABLE | GVDA_NO_LARGER_THAN_CONTENT;
    GVI_vertAttrs  = @default | GVDA_SCROLLABLE | GVDA_NO_LARGER_THAN_CONTENT;
    GVI_content = process;
    GVI_docBounds = { 0, 0, 500, 450 };

    ATTR_GEN_VIEW_DOES_NOT_ACCEPT_TEXT_INPUT;
}

@object GenTextClass LogText = {
    HINT_EXPAND_WIDTH_TO_FIT_PARENT;
	  HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
}

@end Interface;

/********************************************************************
 * Zeichensatz rendern
 ********************************************************************/
void TtfDraw( GStateHandle gstate ) {
    word character;

    // Zeichensatz durchlaufen in einer 16 x 16 Matrix
    for(character = 32; character <= 255; character++ ) {
       word posX = ( character % 16 ) * FONT_SIZE + FONT_SIZE/2;
       word posY = ( character / 16 ) * FONT_SIZE - FONT_SIZE;

       //TODO: Zeichen character an posX, posY ausgeben
    }
}

TT_UShort getWindowsUnicodeCharMap(TT_Face face) {
    TT_UShort charMap;
    TT_Error error;

    for(charMap = 0; charMap < TT_Get_CharMap_Count(face); charMap++) {
        TT_UShort platformID;
        TT_UShort encodingID;

        error = TT_Get_CharMap_ID(face, charMap, &platformID, &encodingID);
        if(error)
            return -1;

        /* platformId = Windows, encodingId = Unicode */
        if(platformID == 3 && encodingID == 1)
            return charMap;
    }
    return -1;
}

@method TtfProcessClass, MSG_META_EXPOSED {
    GStateHandle gstate = GrCreateState( win );
    char tmpStr[40];
    TT_Face_Properties props;
    TT_Instance instance;
    TT_Glyph glyph;
    TT_UShort charMapId;
    TT_CharMap charMap;
    TT_Glyph_Metrics metrics;
    TT_Raster_Map bitmap;
    TT_Error error;


    error = TT_Init_FreeType(&engine);
    if(error) {
        _log("Fehler bei Initialisierung\r");
        goto Fail;
    }

    error = TT_Open_Face(engine, "Lib.ttf", &face);
    if(error) {
         _log("Fehler beim laden des Fonts\r");
         goto Fail;
    }

    error = TT_Get_Face_Properties(face, &props);
    if(error) {
        _log("Fehler beim laden der Properties\r");
        goto Fail;
    }

    sprintf(tmpStr, "num glyphs:\t%d\r", props.num_Glyphs); _log(tmpStr);
    sprintf(tmpStr, "num faces:\t%d\r", props.num_Faces); _log(tmpStr);
    sprintf(tmpStr, "num names:\t%d\r", props.num_Names); _log(tmpStr);
    sprintf(tmpStr, "num charMaps:\t%d\r", props.num_CharMaps); _log(tmpStr);
    sprintf(tmpStr, "max points:\t%d\r", props.max_Points); _log(tmpStr);
    sprintf(tmpStr, "max contours:\t%d\r", props.max_Contours); _log(tmpStr);

    error = TT_New_Instance(face, &instance);
    if(error) {
        _log("Fehler beim erzeugen einer Instance\r");
        goto Fail;
    }

    error = TT_Set_Instance_CharSize(instance, 9*64);
    if(error) {
        _log("Fehler beim setzen der Pointsize\r");
        goto Fail;
    }

    error = TT_New_Glyph(face, &glyph);
    if(error) {
        _log("Fehler beim anlegen eines Glyphs\r");
        goto Fail;
    }

    charMapId = getWindowsUnicodeCharMap(face);
    if(charMapId < 0) {
        _log("Windows Unicode Charmap nicht gefunden\r");
        goto Fail;
    }

    error = TT_Get_CharMap(face, charMapId, &charMap);
    if(error) {
        _log("Fehler beim laden der CharMap\r");
        goto Fail;
    }

    /* TODO: Index aus CharMap benutzen */
    error = TT_Load_Glyph( instance, glyph, 36, TTLOAD_DEFAULT );
    if(error) {
        _log("Fehler beim laden eines Glyphs\r");
        goto Fail;
    }

    error = TT_Get_Glyph_Metrics(glyph, &metrics);
    if(error) {
        _log("Fehler beim laden der Glyphmetriken\r");
        goto Fail;
    }

    sprintf(tmpStr, "bearingX:\t%d\r", metrics.bearingX >> 6); _log(tmpStr);
    sprintf(tmpStr, "bearingY:\t%d\r", metrics.bearingY >> 6); _log(tmpStr);
    sprintf(tmpStr, "advance:\t%d\r", metrics.advance >> 6); _log(tmpStr);

    error = TT_Get_Glyph_Bitmap(glyph, &bitmap, 0, 0);
       if(error) {
        _log("Fehler beim rendern des Glyphs\r");
        goto Fail;
    }

    GrBeginUpdate( gstate );
    TtfDraw( gstate );
    GrEndUpdate( gstate );

    GrDestroyState( gstate );

    Fail:
        /* Resourcen freigeben */
        return;
}

void _log(char * message) {
   @call LogText::MSG_VIS_TEXT_APPEND_PTR(message, 0);
}

void clear_log() {
  @call LogText::MSG_VIS_TEXT_DELETE_ALL();
}
