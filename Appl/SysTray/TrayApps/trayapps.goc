/*-------------------------------------------------------------------
include files
-------------------------------------------------------------------*/
@include <stdapp.goh>
@include <Objects/eMenuC.goh>
@include <Objects/gFieldC.goh>
@include <iacp.goh>

#include <token.h>
#include <object.h>
#include <string.h>


/*-------------------------------------------------------------------
class & message definitions
-------------------------------------------------------------------*/
@class  TrayAppsProcessClass, GenProcessClass;
    @message void MSG_ADD_INTERACTION();
    @message (GEN_TRIGGER_ACTION) MSG_APP_TRIGGER_PRESSED;
@endc   /* end of class definition */

@class  TrayAppsApplicationClass, GenApplicationClass;
    @message void MSG_EMC_INTERACTION_CREATED(CreateExpressMenuControlItemResponseParams *response = ss:bp);
    @instance   optr    TAAC_itemList      = NullOptr; // this gonna be a ChunkArray soon
@endc   /* end of class definition */

@class  TrayAppsInteractionClass, GenInteractionClass;
    @message void MSG_INIT_APP_TRIGGERS();
    @message word MSG_SET_TRAY_APPS_FOLDER_ID();
    @message word MSG_READ_APPS_IN_FOLDER(MemHandle *trayFilesHan);
    @message word MSG_COUNT_APPS_IN_FOLDER();
    @message void MSG_REMOVE_ALL_APP_TRIGGERS();
    @instance   dword   G_trayAppsFolderID   = 0;
    @instance   word    G_trayAppsFilesCount = 0;
@endc

@class GenGeodeTokenTriggerClass, GenTriggerClass;
    @vardata GeodeToken ATTR_GEODE_TOKEN_TO_PASS;
    @vardata FileLongName ATTR_GEODE_FILE_NAME;
@endc;

@classdecl    TrayAppsProcessClass, neverSaved;
@classdecl    TrayAppsApplicationClass;
@classdecl    TrayAppsInteractionClass;
@classdecl    GenGeodeTokenTriggerClass;

/*-------------------------------------------------------------------
UI Objects
-------------------------------------------------------------------*/
@start  AppResource;

    @object TrayAppsApplicationClass TrayAppsApp =
    {
        GAI_states = (((@default) | (AS_NOT_USER_INTERACTABLE) | (AS_AVOID_TRANSPARENT_DETACH)) & ((~AS_FOCUSABLE) & (~AS_MODELABLE)));
        GI_attrs = ((@default) & (~GA_TARGETABLE));

        GI_visMoniker = list {@TrayAppsAppTextMoniker};
    }

    @visMoniker TrayAppsAppTextMoniker = "TrayApps";

@end    AppResource;


/*-------------------------------------------------------------------
globals & constants
-------------------------------------------------------------------*/
#define MAX_TRAY_TRIGGERS_COUNT 25
#define TRAYAPPS_STD_PATH       SP_USER_DATA

typedef struct
{
    optr    emc;            // Express menu
    optr    interaction;    // interaction for this express menu
} TaiEmcComboStruct;

/*-------------------------------------------------------------------
TrayAppsProcessClass
-------------------------------------------------------------------*/

/*-------------------------------------------------------------------
we're born!
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
    @callsuper();

    @call process::MSG_ADD_INTERACTION();
}

/*-------------------------------------------------------------------
add our special GenInteraction to SysTray
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_ADD_INTERACTION
{
    CreateExpressMenuControlItemParams  cemcip;
    EventHandle                         event;

    cemcip.CEMCIP_feature = CEMCIF_SYSTEM_TRAY;
    cemcip.CEMCIP_class = &TrayAppsInteractionClass;
    cemcip.CEMCIP_itemPriority = CEMCIP_STANDARD_PRIORITY;
    cemcip.CEMCIP_responseMessage = MSG_EMC_INTERACTION_CREATED;
    cemcip.CEMCIP_responseDestination = GeodeGetAppObject(0);
    cemcip.CEMCIP_field = NullOptr;

    event = @record ExpressMenuControlClass::MSG_EXPRESS_MENU_CONTROL_CREATE_ITEM(cemcip);
    GCNListSend(MANUFACTURER_ID_GEOWORKS, GCNSLT_EXPRESS_MENU_OBJECTS, event, 0, 0);

	//
	// add ourselves to GCNSLT_EXPRESS_MENU_CHANGE list
	//
    (void) GCNListAdd(oself, MANUFACTURER_ID_GEOWORKS, GCNSLT_EXPRESS_MENU_CHANGE); // GeodeGetProcessHandle
}


/*-------------------------------------------------------------------
add ourselves to a new express menu
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_NOTIFY_EXPRESS_MENU_CHANGE
{
// **Structures:**
//
// 	typedef enum {
// 		GCNEMNT_CREATED,
// 		GCNEMNT_DESTROYED
// 	} GCNExpressMenuNotificationTypes;

// @importMessage	MetaGCNMessages, void MSG_NOTIFY_EXPRESS_MENU_CHANGE(
// 				GCNExpressMenuNotificationTypes type = bp,
// 				optr affectedExpressMenuControl = cx:dx);

    CreateExpressMenuControlItemParams  cemcip;

    if (type == GCNEMNT_CREATED)
    {
        cemcip.CEMCIP_feature = CEMCIF_SYSTEM_TRAY;
        cemcip.CEMCIP_class = &TrayAppsInteractionClass;
        cemcip.CEMCIP_itemPriority = CEMCIP_STANDARD_PRIORITY;
        cemcip.CEMCIP_responseMessage = MSG_EMC_INTERACTION_CREATED;
        cemcip.CEMCIP_responseDestination = GeodeGetAppObject(0);
        cemcip.CEMCIP_field = NullOptr;

        @call affectedExpressMenuControl::MSG_EXPRESS_MENU_CONTROL_CREATE_ITEM(cemcip);
    }
}

/*-------------------------------------------------------------------
one of our triggers has been pressed, launch app
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_APP_TRIGGER_PRESSED
{
    GeodeToken           gt;
    FileLongName         fname;
    IACPConnection       iacpConnectionToken = IACP_NO_CONNECTION;
    word                 connectionFlags = IACPSM_USER_INTERACTIBLE;
    word                 serverCount;
    MemHandle            hLaunchBlock;
    AppLaunchBlock	     *alb;

    @call trigger::MSG_META_GET_VAR_DATA(ATTR_GEODE_TOKEN_TO_PASS, sizeof(GeodeToken), &gt);
    @call trigger::MSG_META_GET_VAR_DATA(ATTR_GEODE_FILE_NAME, sizeof(FileLongName), &fname);

    hLaunchBlock = IACPCreateDefaultLaunchBlock(MSG_GEN_PROCESS_OPEN_APPLICATION);

    alb = (AppLaunchBlock*) MemLock(hLaunchBlock);
    alb->ALB_appRef.AIR_diskHandle = TRAYAPPS_STD_PATH;
    strcpy(alb->ALB_appRef.AIR_fileName, _TEXT("TRAYAPPS"));
    strcat(alb->ALB_appRef.AIR_fileName, _TEXT("\\"));
    strcat(alb->ALB_appRef.AIR_fileName, &fname);
    MemUnlock(hLaunchBlock);

    iacpConnectionToken = IACPConnect(
        &gt,
        connectionFlags,
        hLaunchBlock,
        NullOptr,
        &serverCount
    );

    if(iacpConnectionToken != IACP_NO_CONNECTION)
    {
        IACPShutdown(iacpConnectionToken, NullOptr);
    }
}


/*-------------------------------------------------------------------
prepare our demise
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
    (void) GCNListRemove(oself, MANUFACTURER_ID_GEOWORKS, GCNSLT_EXPRESS_MENU_CHANGE); // GeodeGetProcessHandle
    return(@callsuper());
}

/*------------------------------------------------------------------
This is called by MSG_META_DETACH and allows for changing the
name of the state file which should be created for the application.
We don't want no state file, so we just return 0.
------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_GEN_PROCESS_CREATE_NEW_STATE_FILE
{
    return 0;
}

/*-------------------------------------------------------------------
TrayAppsApplicationClass
-------------------------------------------------------------------*/
@method TrayAppsApplicationClass, MSG_META_ATTACH
{
    MemHandle   block = NullHandle;
    ChunkHandle ch = NullChunk;

    @callsuper();

    block = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    if (block)
    {
        MemLock(block);
        ch = ChunkArrayCreate(block, sizeof(TaiEmcComboStruct), 0, 0);
        pself->TAAC_itemList = ConstructOptr(block, ch);
        MemUnlock(block);
    }
}

/*-------------------------------------------------------------------
initializes the newly created Express menu trigger
-------------------------------------------------------------------*/
@method TrayAppsApplicationClass, MSG_EMC_INTERACTION_CREATED
{
    TaiEmcComboStruct *elem = (void*) 0;

    if (pself->TAAC_itemList != NullOptr)
    {
        MemLock(HandleOf(pself->TAAC_itemList));

        elem = (TaiEmcComboStruct*) ChunkArrayAppend(pself->TAAC_itemList, 0);
        elem->emc = response->CEMCIRP_expressMenuControl;
        elem->interaction = response->CEMCIRP_newItem;

        @call elem->interaction::MSG_GEN_SET_USABLE(VUM_NOW);

        (void) GCNListAdd(
            elem->interaction,                  // ConstructOptr(GeodeGetProcessHandle(), 0),  // optr to add to list
            MANUFACTURER_ID_GEOWORKS,           // manufacturer ID of list
            GCNSLT_FILE_SYSTEM
        );

        MemUnlock(HandleOf(pself->TAAC_itemList));
    }
}


/*-------------------------------------------------------------------
prepare our demise
-------------------------------------------------------------------*/
@method TrayAppsApplicationClass, MSG_META_DETACH
{
    TaiEmcComboStruct   *elem = (void*) 0;
    word                numElem = 0;
    word                i = 0;

    if (pself->TAAC_itemList != NullOptr)
    {
        MemLock(HandleOf(pself->TAAC_itemList));
        numElem = ChunkArrayGetCount(pself->TAAC_itemList);

        for (i = 0; i < numElem; i++)
        {
            elem = (TaiEmcComboStruct*) ChunkArrayElementToPtr(pself->TAAC_itemList, i,	(void*) 0);

            (void*) GCNListRemove(                  // take us off of notification list
                elem->interaction,                  // ConstructOptr(GeodeGetProcessHandle(), 0), // optr of thread to remove from list
                MANUFACTURER_ID_GEOWORKS,           // manufacturer ID of list
                GCNSLT_FILE_SYSTEM
            );

            @call elem->emc::MSG_EXPRESS_MENU_CONTROL_DESTROY_CREATED_ITEM(elem->interaction, VUM_NOW);
        }

        MemUnlock(HandleOf(pself->TAAC_itemList));
        MemFree(HandleOf(pself->TAAC_itemList));
    }

    @callsuper();
}

/*-------------------------------------------------------------------
TrayAppsInteractionClass
-------------------------------------------------------------------*/

/*-------------------------------------------------------------------
initialize
-------------------------------------------------------------------*/
@method TrayAppsInteractionClass, MSG_META_INITIALIZE
{
    Rectangle   margins = {3, 0, 0, 0};

    @callsuper();

    @call oself::MSG_META_ADD_VAR_DATA(
        (HINT_CUSTOM_EXTRA_MARGINS & (~VDF_SAVE_TO_STATE)),
        sizeof(Rectangle),
        &margins
    );

    @call oself::MSG_META_ADD_VAR_DATA(
        (HINT_ORIENT_CHILDREN_HORIZONTALLY & (~VDF_SAVE_TO_STATE)),
        0,
        (void*) 0
    );

    @call oself::MSG_META_ADD_VAR_DATA(
        (HINT_CUSTOM_CHILD_SPACING & (~VDF_SAVE_TO_STATE)),
        sizeof(word),
        (void*) 0
    );

    if (@call oself::MSG_SET_TRAY_APPS_FOLDER_ID())
    {
        @call oself::MSG_INIT_APP_TRIGGERS();
    }
}

/*-------------------------------------------------------------------
add / remove / re-add launchers
-------------------------------------------------------------------*/
@method TrayAppsInteractionClass, MSG_SET_TRAY_APPS_FOLDER_ID
{
    MemHandle   trayAppsFolderIDBlock = 0;
    ChunkHandle trayAppsFolderIDChunk = 0;
    FilePathID  *idArr = 0;

    FilePushDir();
    if (FileSetCurrentPath(TRAYAPPS_STD_PATH, _TEXT("TRAYAPPS")))
    {
        trayAppsFolderIDBlock = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
        trayAppsFolderIDChunk = FileGetCurrentPathIDs(trayAppsFolderIDBlock);
        (void) MemLock(trayAppsFolderIDBlock);
        idArr = (FilePathID*) LMemDerefHandles(trayAppsFolderIDBlock, trayAppsFolderIDChunk);
        pself->G_trayAppsFolderID = idArr->FPID_id;
        MemUnlock(trayAppsFolderIDBlock);
        return TRUE;
    }
    FilePopDir();

    return FALSE;
}

/*-------------------------------------------------------------------
add / remove / re-add launchers
-------------------------------------------------------------------*/
@method TrayAppsInteractionClass, MSG_INIT_APP_TRIGGERS
{
    optr                triggerObj = NullOptr;
    Boolean             isGMoniker = FALSE;
    MemHandle           newMoniker = NULL;
    word                monikerSize = 0;
    GeodeToken          tok;
    char*               filePtr = (void*) 0;
    byte                triggerNo = 0;
    MemHandle           trayFilesHan = NullHandle;
    MemHandle           triggerBlock = NullHandle;

    @call oself::MSG_REMOVE_ALL_APP_TRIGGERS();

    triggerBlock = OptrToHandle(oself);

    pself->G_trayAppsFilesCount = @call oself::MSG_READ_APPS_IN_FOLDER(&trayFilesHan);
    if (pself->G_trayAppsFilesCount > 0)
    {
        for (triggerNo=0; triggerNo < pself->G_trayAppsFilesCount; triggerNo++)
        {
            if (triggerNo >= MAX_TRAY_TRIGGERS_COUNT) break;

            filePtr = MemLock(trayFilesHan);
            filePtr = filePtr + (triggerNo * FILE_LONGNAME_BUFFER_SIZE);
            FileGetPathExtAttributes(filePtr, FEA_TOKEN, (&tok), sizeof(GeodeToken));

            triggerObj = ObjInstantiate(triggerBlock, &GenGeodeTokenTriggerClass);

            if (triggerObj != NullOptr)
            {
                @call oself::MSG_GEN_ADD_CHILD(triggerObj, CCO_LAST);

                isGMoniker = TokenLoadMonikerBlock(
                    TOKEN_CHARS(tok.GT_chars[0],tok.GT_chars[1],tok.GT_chars[2],tok.GT_chars[3]),
                    tok.GT_manufID,
                    (DT_DISP_SIZE | DT_DISP_ASPECT_RATIO | DT_DISP_CLASS),
                    ((VMSF_GSTRING) | (VMS_TOOL << VMSF_STYLE_OFFSET)),
                    &monikerSize,
                    &newMoniker
                );

                if (isGMoniker)
                {
                    @call triggerObj::MSG_GEN_REPLACE_VIS_MONIKER(
                        VUM_NOW,
                        0, 0, monikerSize,
                        VMDT_VIS_MONIKER,
                        VMST_HPTR,
                        (dword)(ConstructOptr(newMoniker, 0))
                    );

                    @call triggerObj::MSG_GEN_TRIGGER_SET_ACTION_MSG(MSG_APP_TRIGGER_PRESSED);
                    @call triggerObj::MSG_GEN_TRIGGER_SET_DESTINATION(ConstructOptr(GeodeGetCodeProcessHandle(), 0));
                    //@call obj::MSG_META_ADD_VAR_DATA(HINT_NO_BORDERS_ON_MONIKERS, 0, (void*) 0);
                    @call triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_TOKEN_TO_PASS & (~VDF_SAVE_TO_STATE)), sizeof(GeodeToken), &tok);
                    @call triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_FILE_NAME & (~VDF_SAVE_TO_STATE)), sizeof(FileLongName), filePtr);
                    @call triggerObj::MSG_GEN_SET_USABLE(VUM_NOW);

                    MemFree(newMoniker);
                }

                @call triggerObj::MSG_GEN_SET_USABLE(VUM_NOW);
            }

            MemUnlock(trayFilesHan);
        }
    }
}

/*-------------------------------------------------------------------
let's see if someone put something in/out of our folder
-------------------------------------------------------------------*/
@method TrayAppsInteractionClass, MSG_NOTIFY_FILE_CHANGE
{
    FileChangeBatchNotificationData *notificationData;
    FileChangeBatchNotificationItem *notificationItem = 0;
    word                            numFiles = 0;

    if (notifyType == FCNT_BATCH)
    {
        notificationData = (FileChangeBatchNotificationData*) MemLock(data);
        notificationItem = &notificationData->FCBND_notifications[0];

        while(((word) notificationItem) < notificationData->FCBND_end)
        {
            word itemSize;

            if ((notificationItem->FCBNI_type == FCNT_CREATE) &&
                (pself->G_trayAppsFolderID == notificationItem->FCBNI_id))
            {
                pself->G_trayAppsFilesCount = @call oself::MSG_COUNT_APPS_IN_FOLDER();
                @call oself::MSG_INIT_APP_TRIGGERS();
                break;
            }

            if (notificationItem->FCBNI_type == FCNT_DELETE)
            {
                numFiles = @call oself::MSG_COUNT_APPS_IN_FOLDER();
                if (numFiles < pself->G_trayAppsFilesCount)
                {
                    pself->G_trayAppsFilesCount = numFiles;
                    @call oself::MSG_INIT_APP_TRIGGERS();
                    break;
                }
            }

            if (
                 (notificationItem->FCBNI_type == FCNT_CREATE) ||
                 (notificationItem->FCBNI_type == FCNT_RENAME)
               )
            {
                /* skip large item for next */
                itemSize = sizeof(FileChangeBatchNotificationItem);
            }
            else
            {
                /* skip small item for next */
                itemSize = sizeof(offsetof(FileChangeBatchNotificationItem, FCBNI_name));
            }

            notificationItem = (FileChangeBatchNotificationItem*) (((byte*) notificationItem) + itemSize);
        }

        MemUnlock(data);
    }

    @callsuper();
}

/*-------------------------------------------------------------------
read apps in folder into passed variable: MemHandle *trayFilesHan
numOfFiles returned
-------------------------------------------------------------------*/
@method TrayAppsInteractionClass, MSG_READ_APPS_IN_FOLDER
{
    FileEnumParams       fileEnumParams;
    word                 filesNotHandled = NULL;
    word                 numOfFiles = NULL;

    fileEnumParams.FEP_searchFlags = FESF_GEOS_EXECS;
    fileEnumParams.FEP_returnAttrs = (void*) FESRT_NAME;  /* Return the file's Geos filename.*/
    fileEnumParams.FEP_returnSize = FILE_LONGNAME_BUFFER_SIZE;
    fileEnumParams.FEP_bufSize = FE_BUFSIZE_UNLIMITED;    /* FE_BUFSIZE_UNLIMITED allows the return buffer size to be as large as necessary.*/
    fileEnumParams.FEP_matchAttrs = 0;  /* Set matchAttrs to zero so it will match anything.*/
    fileEnumParams.FEP_skipCount = 0;   /* Don't skip any files*/
    fileEnumParams.FEP_callback = 0;   /* Don't need no callback. */

    if (*trayFilesHan != NullHandle)
    {
        MemFree(*trayFilesHan);
    }

    FilePushDir();
    FileSetCurrentPath(TRAYAPPS_STD_PATH, _TEXT("TRAYAPPS"));
    numOfFiles = FileEnum(
        &fileEnumParams,
        trayFilesHan,
        &filesNotHandled
    );
    FilePopDir();

    return(numOfFiles);
}

/*-------------------------------------------------------------------
count apps in folder
numOfFiles returned
-------------------------------------------------------------------*/
@method TrayAppsInteractionClass, MSG_COUNT_APPS_IN_FOLDER
{
    FileEnumParams       fileEnumParams;
    word                 numOfFiles = NULL;

    fileEnumParams.FEP_searchFlags = FESF_GEOS_EXECS;
    fileEnumParams.FEP_returnAttrs = (void*) FESRT_COUNT_ONLY;  /*Return the file's Geos filename.*/
    fileEnumParams.FEP_returnSize = 0;
    fileEnumParams.FEP_bufSize = FE_BUFSIZE_UNLIMITED;    /* FE_BUFSIZE_UNLIMITED allows the return buffer size to be as large as necessary.*/
    fileEnumParams.FEP_matchAttrs = 0;  /* Set matchAttrs to zero so it will match anything.*/
    fileEnumParams.FEP_skipCount = 0;   /* Don't skip any files*/
    fileEnumParams.FEP_callback = 0;   /* Don't need no callback. */

    FilePushDir();
    FileSetCurrentPath(TRAYAPPS_STD_PATH, _TEXT("TRAYAPPS"));
    (void) FileEnum(&fileEnumParams, NullHandle, &numOfFiles);
    FilePopDir();

    return numOfFiles;
}

/*-------------------------------------------------------------------
remove all our triggers from SysTray
-------------------------------------------------------------------*/
@method TrayAppsInteractionClass, MSG_REMOVE_ALL_APP_TRIGGERS
{
    optr    trigger = NullOptr;

    while(TRUE)
    {
        trigger = @call oself::MSG_GEN_FIND_CHILD_AT_POSITION(0);
        if (trigger == NullOptr) break;
        @call trigger::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
        @call oself::MSG_GEN_REMOVE_CHILD(trigger, CCF_MARK_DIRTY);
        @call trigger::MSG_META_OBJ_FREE();
    }
}

/*-------------------------------------------------------------------
Dummy for Swat
-------------------------------------------------------------------*/
void ShowStopper()
{
    // Dummy for Swatting
    return;
}
