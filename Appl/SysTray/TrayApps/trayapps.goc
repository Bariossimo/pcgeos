/*-------------------------------------------------------------------
include files
-------------------------------------------------------------------*/
@include <stdapp.goh>
@include <Objects/eMenuC.goh>
@include <Objects/gFieldC.goh>
@include <iacp.goh>

#include <token.h>
#include <object.h>
#include <string.h>


/*-------------------------------------------------------------------
class & message definitions
-------------------------------------------------------------------*/
@class  TrayAppsProcessClass, GenProcessClass;
    @message void MSG_EMC_INTERACTION_CREATED(CreateExpressMenuControlItemResponseParams *response = ss:bp);
    @message (GEN_TRIGGER_ACTION) MSG_APP_TRIGGER_PRESSED;
    @message word MSG_SET_TRAY_APPS_FOLDER_ID(); // returns Boolean
    @message word MSG_READ_APPS_IN_FOLDER();    // reads into TAPC_filesMemHan
    @message word MSG_COUNT_APPS_IN_FOLDER();
    @message void MSG_UPDATE_EVERY_TRAY_APPS_INTERACTION();
@endc   /* end of class definition */

@class  TrayAppsInteractionClass, GenInteractionClass;
    @message void MSG_INIT_APP_TRIGGERS(MemHandle trayFilesHan, word trayFilesCount);
    @message void MSG_REMOVE_ALL_APP_TRIGGERS();
@endc

@class GenGeodeTokenTriggerClass, GenTriggerClass;
    @vardata GeodeToken ATTR_GEODE_TOKEN_TO_PASS;
    @vardata FileLongName ATTR_GEODE_FILE_NAME;
@endc;

@classdecl    TrayAppsProcessClass, neverSaved;
@classdecl    TrayAppsInteractionClass;
@classdecl    GenGeodeTokenTriggerClass;


/*-------------------------------------------------------------------
UI Objects
-------------------------------------------------------------------*/
@start  AppResource;

    @include <appicon.goh>

    @object GenApplicationClass TrayAppsApp =
    {
        GI_visMoniker = list {
            @Moniker0,
            @Moniker1,
            @Moniker3,
            @TrayAppsAppTextMoniker
        };

        GAI_states = (((@default) | (AS_NOT_USER_INTERACTABLE) | (AS_AVOID_TRANSPARENT_DETACH)) & ((~AS_FOCUSABLE) & (~AS_MODELABLE)));
        GI_attrs = ((@default) & (~GA_TARGETABLE));
    }

    @visMoniker TrayAppsAppTextMoniker = "TrayApps";

@end    AppResource;


/*-------------------------------------------------------------------
constants & structures
-------------------------------------------------------------------*/
#define MAX_TRAY_TRIGGERS_COUNT 25
#define TRAYAPPS_STD_PATH       SP_USER_DATA

typedef struct
{
    optr    emc;            // Express menu
    optr    interaction;    // interaction for this express menu
} TaiEmcComboStruct;


/*-------------------------------------------------------------------
globals variables - "instance data" of process class
-------------------------------------------------------------------*/
optr        TAPC_itemList       = NullOptr; // this gonna be a ChunkArray soon
dword       TAPC_folderID       = 0;
word        TAPC_filesCount     = 0;
MemHandle   TAPC_filesMemHan    = NullHandle;


/*-------------------------------------------------------------------
TrayAppsProcessClass
-------------------------------------------------------------------*/

/*-------------------------------------------------------------------
we're born!
add our special GenInteraction to SysTray
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
    CreateExpressMenuControlItemParams  cemcip;
    EventHandle                         event;
    MemHandle                           block = NullHandle;
    ChunkHandle                         ch = NullChunk;

    @callsuper();

    block = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    if (block)
    {
        MemLock(block);
        ch = ChunkArrayCreate(block, sizeof(TaiEmcComboStruct), 0, 0);
        TAPC_itemList = ConstructOptr(block, ch);
        MemUnlock(block);
    }

    cemcip.CEMCIP_feature = CEMCIF_SYSTEM_TRAY;
    cemcip.CEMCIP_class = &TrayAppsInteractionClass;
    cemcip.CEMCIP_itemPriority = CEMCIP_STANDARD_PRIORITY;
    cemcip.CEMCIP_responseMessage = MSG_EMC_INTERACTION_CREATED;
    cemcip.CEMCIP_responseDestination = oself;
    cemcip.CEMCIP_field = NullOptr;

    event = @record ExpressMenuControlClass::MSG_EXPRESS_MENU_CONTROL_CREATE_ITEM(cemcip);
    GCNListSend(MANUFACTURER_ID_GEOWORKS, GCNSLT_EXPRESS_MENU_OBJECTS, event, 0, 0);

    // add ourselves to GCNSLT_EXPRESS_MENU_CHANGE list
    (void) GCNListAdd(oself, MANUFACTURER_ID_GEOWORKS, GCNSLT_EXPRESS_MENU_CHANGE); // GeodeGetProcessHandle

    if (@call oself::MSG_SET_TRAY_APPS_FOLDER_ID())
    {
        TAPC_filesCount = @call oself::MSG_READ_APPS_IN_FOLDER();
    }

    // add ourselves to GCNSLT_FILE_SYSTEM list
    (void) GCNListAdd(oself, MANUFACTURER_ID_GEOWORKS, GCNSLT_FILE_SYSTEM);
}

/*-------------------------------------------------------------------
add ourselves to a new express menu
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_NOTIFY_EXPRESS_MENU_CHANGE
{
// **Structures:**
//
// 	typedef enum {
// 		GCNEMNT_CREATED,
// 		GCNEMNT_DESTROYED
// 	} GCNExpressMenuNotificationTypes;
//
//  @importMessage	MetaGCNMessages, void MSG_NOTIFY_EXPRESS_MENU_CHANGE(
//   				GCNExpressMenuNotificationTypes type = bp,
//      			optr affectedExpressMenuControl = cx:dx);

    CreateExpressMenuControlItemParams  cemcip;
    TaiEmcComboStruct                   *elem = (void*) 0;
    word                                numElem = 0;
    word                                i = 0;

    if (type == GCNEMNT_CREATED)
    {
        cemcip.CEMCIP_feature = CEMCIF_SYSTEM_TRAY;
        cemcip.CEMCIP_class = &TrayAppsInteractionClass;
        cemcip.CEMCIP_itemPriority = CEMCIP_STANDARD_PRIORITY;
        cemcip.CEMCIP_responseMessage = MSG_EMC_INTERACTION_CREATED;
        cemcip.CEMCIP_responseDestination = oself;
        cemcip.CEMCIP_field = NullOptr;

        @call affectedExpressMenuControl::MSG_EXPRESS_MENU_CONTROL_CREATE_ITEM(cemcip);
    }

    if (type == GCNEMNT_DESTROYED)
    {
        if (TAPC_itemList != NullOptr)
        {
            MemLock(HandleOf(TAPC_itemList));
            numElem = ChunkArrayGetCount(TAPC_itemList);

            for (i = 0; i < numElem; i++)
            {
                elem = (TaiEmcComboStruct*) ChunkArrayElementToPtr(TAPC_itemList, i, (void*) 0);
                if (elem->emc == affectedExpressMenuControl)
                {
                    //if this is the last element, remove ourselves from GCNSLT_FILE_SYSTEM
                    if (numElem == 1)
                    {
                        (void) GCNListRemove(oself, MANUFACTURER_ID_GEOWORKS, GCNSLT_FILE_SYSTEM);
                    }

                    (void) ChunkArrayDeleteRange(
                            TAPC_itemList,                  // optr to chunk array
                            i,	                         // index of first element to delete
                            1);			                 // # of elements to delete
                    break;
                }
            }

            MemUnlock(HandleOf(TAPC_itemList));
        }
    }

}

/*-------------------------------------------------------------------
initializes the newly created Express menu trigger
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_EMC_INTERACTION_CREATED
{
    TaiEmcComboStruct   *elem = (void*) 0;

    if (TAPC_itemList != NullOptr)
    {
        MemLock(HandleOf(TAPC_itemList));

        elem = (TaiEmcComboStruct*) ChunkArrayAppend(TAPC_itemList, 0);

        elem->emc = response->CEMCIRP_expressMenuControl;
        elem->interaction = response->CEMCIRP_newItem;

        @call elem->interaction::MSG_GEN_SET_USABLE(VUM_NOW);
        @call elem->interaction::MSG_INIT_APP_TRIGGERS(TAPC_filesMemHan, TAPC_filesCount);

        MemUnlock(HandleOf(TAPC_itemList));
    }
}

/*-------------------------------------------------------------------
one of our triggers has been pressed, launch app
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_APP_TRIGGER_PRESSED
{
    GeodeToken           gt;
    FileLongName         fname;
    IACPConnection       iacpConnectionToken = IACP_NO_CONNECTION;
    word                 connectionFlags = IACPSM_USER_INTERACTIBLE;
    word                 serverCount;
    MemHandle            hLaunchBlock;
    AppLaunchBlock	     *alb;

    @call trigger::MSG_META_GET_VAR_DATA(ATTR_GEODE_TOKEN_TO_PASS, sizeof(GeodeToken), &gt);
    @call trigger::MSG_META_GET_VAR_DATA(ATTR_GEODE_FILE_NAME, sizeof(FileLongName), &fname);

    hLaunchBlock = IACPCreateDefaultLaunchBlock(MSG_GEN_PROCESS_OPEN_APPLICATION);

    alb = (AppLaunchBlock*) MemLock(hLaunchBlock);
    alb->ALB_appRef.AIR_diskHandle = TRAYAPPS_STD_PATH;
    strcpy(alb->ALB_appRef.AIR_fileName, _TEXT("TRAYAPPS"));
    strcat(alb->ALB_appRef.AIR_fileName, _TEXT("\\"));
    strcat(alb->ALB_appRef.AIR_fileName, &fname);
    MemUnlock(hLaunchBlock);

    iacpConnectionToken = IACPConnect(
        &gt,
        connectionFlags,
        hLaunchBlock,
        NullOptr,
        &serverCount
    );

    if(iacpConnectionToken != IACP_NO_CONNECTION)
    {
        IACPShutdown(iacpConnectionToken, NullOptr);
    }
}

/*-------------------------------------------------------------------
add / remove / re-add launchers
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_SET_TRAY_APPS_FOLDER_ID
{
    MemHandle   trayAppsFolderIDBlock = 0;
    ChunkHandle trayAppsFolderIDChunk = 0;
    FilePathID  *idArr = 0;

    FilePushDir();
    if (FileSetCurrentPath(TRAYAPPS_STD_PATH, _TEXT("TRAYAPPS")))
    {
        trayAppsFolderIDBlock = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
        trayAppsFolderIDChunk = FileGetCurrentPathIDs(trayAppsFolderIDBlock);
        (void) MemLock(trayAppsFolderIDBlock);
        idArr = (FilePathID*) LMemDerefHandles(trayAppsFolderIDBlock, trayAppsFolderIDChunk);
        TAPC_folderID = idArr->FPID_id;
        MemUnlock(trayAppsFolderIDBlock);
        return TRUE;
    }
    FilePopDir();

    return FALSE;
}

/*-------------------------------------------------------------------
let's see if someone put something in/out of our folder
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_NOTIFY_FILE_CHANGE
{
    FileChangeBatchNotificationData *notificationData;
    FileChangeBatchNotificationItem *notificationItem = 0;
    word                            numFilesCurrent = 0;

    if (notifyType == FCNT_BATCH)
    {
        notificationData = (FileChangeBatchNotificationData*) MemLock(data);
        notificationItem = &notificationData->FCBND_notifications[0];

        while(((word) notificationItem) < notificationData->FCBND_end)
        {
            word itemSize;

            if ((notificationItem->FCBNI_type == FCNT_CREATE) &&
                (TAPC_folderID == notificationItem->FCBNI_id))
            {
                TAPC_filesCount = @call oself::MSG_READ_APPS_IN_FOLDER();
                @call oself::MSG_UPDATE_EVERY_TRAY_APPS_INTERACTION();
                break;
            }

            if (notificationItem->FCBNI_type == FCNT_DELETE)
            {
                numFilesCurrent = @call oself::MSG_COUNT_APPS_IN_FOLDER();
                if (numFilesCurrent < TAPC_filesCount)
                {
                    TAPC_filesCount = numFilesCurrent;
                    (void) @call oself::MSG_READ_APPS_IN_FOLDER();
                    @call oself::MSG_UPDATE_EVERY_TRAY_APPS_INTERACTION();
                    break;
                }
            }

            if (
                 (notificationItem->FCBNI_type == FCNT_CREATE) ||
                 (notificationItem->FCBNI_type == FCNT_RENAME)
               )
            {
                /* skip large item for next */
                itemSize = sizeof(FileChangeBatchNotificationItem);
            }
            else
            {
                /* skip small item for next */
                itemSize = sizeof(offsetof(FileChangeBatchNotificationItem, FCBNI_name));
            }

            notificationItem = (FileChangeBatchNotificationItem*) (((byte*) notificationItem) + itemSize);
        }

        MemUnlock(data);
    }

    @callsuper();
}


/*-------------------------------------------------------------------
update all our GenInteractions in every E-Menu
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_UPDATE_EVERY_TRAY_APPS_INTERACTION
{
    word                i = 0;
    word                numElem = 0;
    TaiEmcComboStruct   *elem = (void*) 0;

    if (TAPC_itemList != NullOptr)
    {
        MemLock(HandleOf(TAPC_itemList));
        numElem = ChunkArrayGetCount(TAPC_itemList);

        for (i = 0; i < numElem; i++)
        {
            elem = (TaiEmcComboStruct*) ChunkArrayElementToPtr(TAPC_itemList, i, (void*) 0);
            @call elem->interaction::MSG_INIT_APP_TRIGGERS(TAPC_filesMemHan, TAPC_filesCount);
        }

        MemUnlock(HandleOf(TAPC_itemList));
    }
}

/*-------------------------------------------------------------------
read apps in folder into TAPC_filesMemHan
returns numOfFiles
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_READ_APPS_IN_FOLDER
{
    FileEnumParams       fileEnumParams;
    word                 filesNotHandled = NULL;
    word                 numOfFiles = NULL;

    fileEnumParams.FEP_searchFlags = FESF_GEOS_EXECS;
    fileEnumParams.FEP_returnAttrs = (void*) FESRT_NAME;  /* Return the file's Geos filename.*/
    fileEnumParams.FEP_returnSize = FILE_LONGNAME_BUFFER_SIZE;
    fileEnumParams.FEP_bufSize = FE_BUFSIZE_UNLIMITED;    /* FE_BUFSIZE_UNLIMITED allows the return buffer size to be as large as necessary.*/
    fileEnumParams.FEP_matchAttrs = 0;  /* Set matchAttrs to zero so it will match anything.*/
    fileEnumParams.FEP_skipCount = 0;   /* Don't skip any files*/
    fileEnumParams.FEP_callback = 0;   /* Don't need no callback. */

    if (TAPC_filesMemHan != NullHandle)
    {
        MemFree(TAPC_filesMemHan);
    }

    FilePushDir();
    FileSetCurrentPath(TRAYAPPS_STD_PATH, _TEXT("TRAYAPPS"));
    numOfFiles = FileEnum(
        &fileEnumParams,
        &TAPC_filesMemHan,
        &filesNotHandled
    );
    FilePopDir();

    return numOfFiles;
}

/*-------------------------------------------------------------------
count apps in folder
returns numOfFiles
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_COUNT_APPS_IN_FOLDER
{
    FileEnumParams       fileEnumParams;
    word                 numOfFiles = NULL;

    fileEnumParams.FEP_searchFlags = FESF_GEOS_EXECS;
    fileEnumParams.FEP_returnAttrs = (void*) FESRT_COUNT_ONLY;  /*Return the file's Geos filename.*/
    fileEnumParams.FEP_returnSize = 0;
    fileEnumParams.FEP_bufSize = FE_BUFSIZE_UNLIMITED;    /* FE_BUFSIZE_UNLIMITED allows the return buffer size to be as large as necessary.*/
    fileEnumParams.FEP_matchAttrs = 0;  /* Set matchAttrs to zero so it will match anything.*/
    fileEnumParams.FEP_skipCount = 0;   /* Don't skip any files*/
    fileEnumParams.FEP_callback = 0;   /* Don't need no callback. */

    FilePushDir();
    FileSetCurrentPath(TRAYAPPS_STD_PATH, _TEXT("TRAYAPPS"));
    (void) FileEnum(&fileEnumParams, NullHandle, &numOfFiles);
    FilePopDir();

    return numOfFiles;
}

/*-------------------------------------------------------------------
prepare our demise
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
    TaiEmcComboStruct   *elem = (void*) 0;
    word                numElem = 0;
    word                i = 0;

    // this must be done in MSG_NOTIFY_EXPRESS_MENU_CHANGE, otherwise GEOS crashs on shutdown:
    // (void) GCNListRemove(oself, MANUFACTURER_ID_GEOWORKS, GCNSLT_FILE_SYSTEM);

    (void) GCNListRemove(oself, MANUFACTURER_ID_GEOWORKS, GCNSLT_EXPRESS_MENU_CHANGE);

    if (TAPC_itemList != NullOptr)
    {
        MemLock(HandleOf(TAPC_itemList));
        numElem = ChunkArrayGetCount(TAPC_itemList);

        for (i = 0; i < numElem; i++)
        {
            elem = (TaiEmcComboStruct*) ChunkArrayElementToPtr(TAPC_itemList, i, (void*) 0);
            @call elem->emc::MSG_EXPRESS_MENU_CONTROL_DESTROY_CREATED_ITEM(elem->interaction, VUM_NOW);
        }

        MemUnlock(HandleOf(TAPC_itemList));
        MemFree(HandleOf(TAPC_itemList));
        TAPC_itemList = NullOptr;
    }

    if (TAPC_filesMemHan != NullHandle)
    {
        MemFree(TAPC_filesMemHan);
    }

    return(@callsuper());
}

/*------------------------------------------------------------------
prevent state file
------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_GEN_PROCESS_CREATE_NEW_STATE_FILE
{
    return 0;
}



/*-------------------------------------------------------------------
TrayAppsInteractionClass
-------------------------------------------------------------------*/

/*-------------------------------------------------------------------
initialize
-------------------------------------------------------------------*/
@method TrayAppsInteractionClass, MSG_META_INITIALIZE
{
    Rectangle   margins = {3, 0, 0, 0};

    @callsuper();

    @call oself::MSG_META_ADD_VAR_DATA(
        (HINT_CUSTOM_EXTRA_MARGINS & (~VDF_SAVE_TO_STATE)),
        sizeof(Rectangle),
        &margins
    );

    @call oself::MSG_META_ADD_VAR_DATA(
        (HINT_ORIENT_CHILDREN_HORIZONTALLY & (~VDF_SAVE_TO_STATE)),
        0,
        (void*) 0
    );

    @call oself::MSG_META_ADD_VAR_DATA(
        (HINT_CUSTOM_CHILD_SPACING & (~VDF_SAVE_TO_STATE)),
        sizeof(word),
        (void*) 0
    );
}

/*-------------------------------------------------------------------
add / remove / re-add launchers
-------------------------------------------------------------------*/
@method TrayAppsInteractionClass, MSG_INIT_APP_TRIGGERS
{
    optr                triggerObj = NullOptr;
    Boolean             isGMoniker = FALSE;
    MemHandle           newMoniker = NULL;
    word                monikerSize = 0;
    GeodeToken          tok;
    char*               filePtr = (void*) 0;
    byte                triggerNo = 0;
    MemHandle           triggerBlock = NullHandle;

    @call oself::MSG_REMOVE_ALL_APP_TRIGGERS();

    triggerBlock = OptrToHandle(oself);

    if (trayFilesCount > 0)
    {
        for (triggerNo=0; triggerNo < trayFilesCount; triggerNo++)
        {
            if (triggerNo >= MAX_TRAY_TRIGGERS_COUNT) break;

            FilePushDir();
            if (FileSetCurrentPath(TRAYAPPS_STD_PATH, _TEXT("TRAYAPPS")))
            {
                filePtr = MemLock(trayFilesHan);
                filePtr = filePtr + (triggerNo * FILE_LONGNAME_BUFFER_SIZE);
                FileGetPathExtAttributes(filePtr, FEA_TOKEN, (&tok), sizeof(GeodeToken));

                triggerObj = ObjInstantiate(triggerBlock, &GenGeodeTokenTriggerClass);

                if (triggerObj != NullOptr)
                {
                    @call oself::MSG_GEN_ADD_CHILD(triggerObj, CCO_LAST);

                    isGMoniker = TokenLoadMonikerBlock(
                        TOKEN_CHARS(tok.GT_chars[0],tok.GT_chars[1],tok.GT_chars[2],tok.GT_chars[3]),
                        tok.GT_manufID,
                        (DT_DISP_SIZE | DT_DISP_ASPECT_RATIO | DT_DISP_CLASS),
                        ((VMSF_GSTRING) | (VMS_TOOL << VMSF_STYLE_OFFSET)),
                        &monikerSize,
                        &newMoniker
                    );

                    if (isGMoniker)
                    {
                        @call triggerObj::MSG_GEN_REPLACE_VIS_MONIKER(
                            VUM_NOW,
                            0, 0, monikerSize,
                            VMDT_VIS_MONIKER,
                            VMST_HPTR,
                            (dword)(ConstructOptr(newMoniker, 0))
                        );

                        @call triggerObj::MSG_GEN_TRIGGER_SET_ACTION_MSG(MSG_APP_TRIGGER_PRESSED);
                        @call triggerObj::MSG_GEN_TRIGGER_SET_DESTINATION(ConstructOptr(GeodeGetCodeProcessHandle(), 0));
                        //@call obj::MSG_META_ADD_VAR_DATA(HINT_NO_BORDERS_ON_MONIKERS, 0, (void*) 0);
                        @call triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_TOKEN_TO_PASS & (~VDF_SAVE_TO_STATE)), sizeof(GeodeToken), &tok);
                        @call triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_FILE_NAME & (~VDF_SAVE_TO_STATE)), sizeof(FileLongName), filePtr);
                        @call triggerObj::MSG_GEN_SET_USABLE(VUM_NOW);

                        MemFree(newMoniker);
                    }

                    @call triggerObj::MSG_GEN_SET_USABLE(VUM_NOW);
                }

                MemUnlock(trayFilesHan);
            }
            FilePopDir();
        }
    }
}

/*-------------------------------------------------------------------
remove all our triggers from SysTray
-------------------------------------------------------------------*/
@method TrayAppsInteractionClass, MSG_REMOVE_ALL_APP_TRIGGERS
{
    optr    trigger = NullOptr;

    while(TRUE)
    {
        trigger = @call oself::MSG_GEN_FIND_CHILD_AT_POSITION(0);
        if (trigger == NullOptr) break;
        @call trigger::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
        @call oself::MSG_GEN_REMOVE_CHILD(trigger, CCF_MARK_DIRTY);
        @call trigger::MSG_META_OBJ_FREE();
    }
}

/*-------------------------------------------------------------------
Dummy for Swat
-------------------------------------------------------------------*/
void ShowStopper()
{
    // Dummy for Swatting
    return;
}
