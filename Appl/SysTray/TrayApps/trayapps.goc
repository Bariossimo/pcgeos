/*-------------------------------------------------------------------
include files
-------------------------------------------------------------------*/
@include <stdapp.goh>
@include <Objects/eMenuC.goh>
@include <Objects/gFieldC.goh>
@include <iacp.goh>

#include <Ansi/stdio.h>
#include <Ansi/string.h>
#include <token.h>
#include <object.h>

/*-------------------------------------------------------------------
globals & constants
-------------------------------------------------------------------*/

dword       G_trayAppsFolderID      = 0;
word        G_triggerNo             = 0;
MemHandle   G_trayFilesHan          = 0;
word        G_trayAppsFilesCount    = 0;
optr        G_trayTriggersArr[25];

#define MAX_TRAY_TRIGGERS_COUNT 25

/*-------------------------------------------------------------------
class & message definitions
-------------------------------------------------------------------*/

@class  TrayAppsProcessClass, GenProcessClass;
    @message void MSG_INIT_APP_TRIGGERS();
    @message void MSG_ADD_APP_TRIGGER();
    @message void MSG_EMC_APP_TRIGGER_CREATED(CreateExpressMenuControlItemResponseParams *response = ss:bp);
    @message (GEN_TRIGGER_ACTION) MSG_APP_TRIGGER_PRESSED;
    @message void MSG_REMOVE_ALL_APP_TRIGGERS();
    @message word MSG_READ_APPS_IN_FOLDER(MemHandle* FilesToReturn);
    @message word MSG_COUNT_APPS_IN_FOLDER();
@endc   /* end of class definition */

@class GenGeodeTokenTriggerClass, GenTriggerClass;
    @vardata GeodeToken ATTR_GEODE_TOKEN_TO_PASS;
@endc;

@classdecl   TrayAppsProcessClass, neverSaved;
@classdecl   GenGeodeTokenTriggerClass, neverSaved;

/*-------------------------------------------------------------------
UI Objects
-------------------------------------------------------------------*/

@start  AppResource;

    @object GenApplicationClass TrayAppsApp =
    {
        GAI_states = (((@default) | (AS_NOT_USER_INTERACTABLE) | (AS_AVOID_TRANSPARENT_DETACH)) & ((~AS_FOCUSABLE) & (~AS_MODELABLE)));
        GI_attrs = ((@default) & (~GA_TARGETABLE));

        GI_visMoniker = list {@TrayAppsAppTextMoniker};
    }

    @visMoniker TrayAppsAppTextMoniker = "TrayApps";

@end    AppResource;


/*-------------------------------------------------------------------
we're born!
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
    MemHandle   trayAppsFolderIDBlock   = 0;
    ChunkHandle trayAppsFolderIDChunk   = 0;
    FilePathID  *idArr                  = 0;
    //dword       no = 0;

    @callsuper();

    if (FileSetCurrentPath(SP_APPLICATION, "TrayApps"))
    {
        trayAppsFolderIDBlock = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
        trayAppsFolderIDChunk = FileGetCurrentPathIDs(trayAppsFolderIDBlock);
        (void) MemLock(trayAppsFolderIDBlock);
        idArr = (FilePathID*) LMemDerefHandles(trayAppsFolderIDBlock, trayAppsFolderIDChunk);
        //no = LMemGetChunkSizeHandles(trayAppsFolderIDBlock, trayAppsFolderIDChunk) / sizeof(FilePathID);
        G_trayAppsFolderID = idArr->FPID_id;
        MemUnlock(trayAppsFolderIDBlock);

        @call process::MSG_INIT_APP_TRIGGERS();
    }

    (void) GCNListAdd(
        ConstructOptr(GeodeGetProcessHandle(), 0),  // optr to add to list
        MANUFACTURER_ID_GEOWORKS,                   // manufacturer ID of list
        GCNSLT_FILE_SYSTEM
    );
}

/*-------------------------------------------------------------------
let's see if someone put something in/out of our folder
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_NOTIFY_FILE_CHANGE
{
    FileChangeBatchNotificationData *notificationData;
    FileChangeBatchNotificationItem *notificationItem = 0;
    word                            numFiles = 0;

    if (notifyType == FCNT_BATCH)
    {
        notificationData = (FileChangeBatchNotificationData*) MemLock(data);
        notificationItem = &notificationData->FCBND_notifications[0];

        while(((word) notificationItem) < notificationData->FCBND_end)
        {
            word itemSize;

            if ((notificationItem->FCBNI_type == FCNT_CREATE) &&
                (G_trayAppsFolderID == notificationItem->FCBNI_id))
            {
                G_trayAppsFilesCount = @call process::MSG_COUNT_APPS_IN_FOLDER();
                @call process::MSG_INIT_APP_TRIGGERS();
                break;
            }

            if (notificationItem->FCBNI_type == FCNT_DELETE)
            {
                numFiles = @call process::MSG_COUNT_APPS_IN_FOLDER();
                if (numFiles < G_trayAppsFilesCount)
                {
                    G_trayAppsFilesCount = numFiles;
                    @call process::MSG_INIT_APP_TRIGGERS();
                    break;
                }
            }

            if (
                 (notificationItem->FCBNI_type == FCNT_CREATE) ||
                 (notificationItem->FCBNI_type == FCNT_RENAME)
               )
            {
                /* skip large item for next */
                itemSize = sizeof(FileChangeBatchNotificationItem);
            }
            else
            {
                /* skip small item for next */
                itemSize = sizeof(offsetof(FileChangeBatchNotificationItem, FCBNI_name));
            }

            notificationItem = (FileChangeBatchNotificationItem*) (((byte*) notificationItem) + itemSize);
        }

        MemUnlock(data);
    }

    @callsuper();
}

/*-------------------------------------------------------------------
add / remove / re-add launchers
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_INIT_APP_TRIGGERS
{
    @call process::MSG_REMOVE_ALL_APP_TRIGGERS();

    G_trayAppsFilesCount = @call process::MSG_READ_APPS_IN_FOLDER(&G_trayFilesHan);
    if (G_trayAppsFilesCount > 0)
    {
        @call process::MSG_ADD_APP_TRIGGER();
    }
}

/*-------------------------------------------------------------------
add another app trigger
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_ADD_APP_TRIGGER
{
    CreateExpressMenuControlItemParams  cemcip;
    EventHandle                         event;

    if ((G_triggerNo < G_trayAppsFilesCount) &&
        (G_triggerNo < MAX_TRAY_TRIGGERS_COUNT))
    {
        /*cemcip.CEMCIP_feature = CEMCIF_UTILITIES_PANEL;*/
        cemcip.CEMCIP_feature = CEMCIF_SYSTEM_TRAY;
        cemcip.CEMCIP_class = &GenGeodeTokenTriggerClass;
        cemcip.CEMCIP_itemPriority = CEMCIP_STANDARD_PRIORITY;
        cemcip.CEMCIP_responseMessage = MSG_EMC_APP_TRIGGER_CREATED;
        cemcip.CEMCIP_responseDestination = oself;
        cemcip.CEMCIP_field = NullOptr;

        event = @record ExpressMenuControlClass::MSG_EXPRESS_MENU_CONTROL_CREATE_ITEM(cemcip);
        GCNListSend(MANUFACTURER_ID_GEOWORKS, GCNSLT_EXPRESS_MENU_OBJECTS, event, 0, 0);
    }
}

/*-------------------------------------------------------------------
initializes the newly created Express menu trigger
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_EMC_APP_TRIGGER_CREATED
{
    optr           obj = NULL;
    Boolean        isGMoniker = FALSE;
    MemHandle      newMoniker = NULL;
    word           monikerSize = 0;
    GeodeToken     tok;
    char*          filePtr = (void*) 0;

    //optr*          fh  = NULL;
    //ChunkHandle    helpChunk = NULL;
    //char*          helpChunkPtr = NULL;

    filePtr = MemLock(G_trayFilesHan);
    filePtr = filePtr + (G_triggerNo * FILE_LONGNAME_BUFFER_SIZE);
    FileGetPathExtAttributes(filePtr, FEA_TOKEN, (&tok), sizeof(GeodeToken));
    // MemLock(OptrToHandle(@MinimHelp));
    // helpChunk = LMemAlloc(OptrToHandle(@MinimHelp), FILE_LONGNAME_BUFFER_SIZE);
    // helpChunkPtr = LMemDerefHandles(OptrToHandle(@MinimHelp), helpChunk);
    // strcpy(helpChunkPtr, filePtr);
    // MemUnlock(OptrToHandle(@MinimHelp));
    MemUnlock(G_trayFilesHan);

    obj = response->CEMCIRP_newItem;

    isGMoniker = TokenLoadMonikerBlock(
                        TOKEN_CHARS(tok.GT_chars[0],tok.GT_chars[1],tok.GT_chars[2],tok.GT_chars[3]),
                        tok.GT_manufID,
                        (DT_DISP_SIZE | DT_DISP_ASPECT_RATIO | DT_DISP_CLASS),
                        ((VMSF_GSTRING) | (VMS_TOOL << VMSF_STYLE_OFFSET)),
                        &monikerSize,
                        &newMoniker);

    if (isGMoniker)
    {
        @call obj::MSG_GEN_REPLACE_VIS_MONIKER(
            VUM_NOW,
            0, 0, monikerSize,
            VMDT_VIS_MONIKER,
            VMST_HPTR,
            (dword)(ConstructOptr(newMoniker, 0))
        );
    }

    @call obj::MSG_GEN_TRIGGER_SET_ACTION_MSG(MSG_APP_TRIGGER_PRESSED);
    @call obj::MSG_GEN_TRIGGER_SET_DESTINATION(oself);
    //@call obj::MSG_META_ADD_VAR_DATA(HINT_NO_BORDERS_ON_MONIKERS, 0, (void*) 0);
    @call obj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_TOKEN_TO_PASS & (~VDF_SAVE_TO_STATE)), sizeof(GeodeToken), &tok);

    // MemLock(HandleOf(obj));
    // fh = (optr*) ObjVarAddData(obj, (ATTR_GEN_FOCUS_HELP & (~VDF_SAVE_TO_STATE)), sizeof(optr));
    // (*fh) = ConstructOptr(OptrToHandle(@MinimHelp), helpChunk);
    // ObjSetFlags(obj, OCF_VARDATA_RELOC, 0);
    // MemUnlock(HandleOf(obj));

    @call obj::MSG_GEN_SET_USABLE(VUM_NOW);
    G_trayTriggersArr[G_triggerNo] = obj;

    G_triggerNo++;
    MemFree(newMoniker);

    @call process::MSG_ADD_APP_TRIGGER();
}

/*-------------------------------------------------------------------
one of our triggers has been pressed, launch app
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_APP_TRIGGER_PRESSED
{
    GeodeToken           gt;
    IACPConnection       iacpConnectionToken = IACP_NO_CONNECTION;
    word                 connectionFlags = IACPSM_USER_INTERACTIBLE;
    word                 serverCount;
    MemHandle            hLaunchBlock;

    @call trigger::MSG_META_GET_VAR_DATA(ATTR_GEODE_TOKEN_TO_PASS, sizeof(GeodeToken), &gt);

    hLaunchBlock = IACPCreateDefaultLaunchBlock(MSG_GEN_PROCESS_OPEN_APPLICATION);
    iacpConnectionToken = IACPConnect(
        &gt,
        connectionFlags,
        hLaunchBlock,
        NullOptr,
        &serverCount
    );

    if(iacpConnectionToken != IACP_NO_CONNECTION)
    {
        IACPShutdown(iacpConnectionToken, NullOptr);
    }
}

/*-------------------------------------------------------------------
prepare our demise
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
    // take us off of notification list
    (void) GCNListRemove(
        ConstructOptr(GeodeGetProcessHandle(), 0),  // optr of thread to remove from list
        MANUFACTURER_ID_GEOWORKS,                   // manufacturer ID of list
        GCNSLT_FILE_SYSTEM
    );

    // clean up handle
    if (G_trayFilesHan) MemFree(G_trayFilesHan);

    // remove triggers
    @call process::MSG_REMOVE_ALL_APP_TRIGGERS();

    return(@callsuper());
}

/*-------------------------------------------------------------------
remove all our triggers from SysTray
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_REMOVE_ALL_APP_TRIGGERS
{
    EventHandle    event;

    if (G_triggerNo > 0)
    {
        while(G_triggerNo--)
        {
            event = @record ExpressMenuControlClass::MSG_EXPRESS_MENU_CONTROL_DESTROY_CREATED_ITEM(G_trayTriggersArr[G_triggerNo], VUM_NOW);
            GCNListSend(MANUFACTURER_ID_GEOWORKS, GCNSLT_EXPRESS_MENU_OBJECTS, event, 0, 0);
        }
    }

    G_triggerNo = 0;
}

/*-------------------------------------------------------------------
read apps in folder into MemHandle
numOfFiles returned
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_READ_APPS_IN_FOLDER
{
    FileEnumParams       fileEnumParams;
    word                 filesNotHandled = NULL;
    word                 numOfFiles = NULL;

    fileEnumParams.FEP_searchFlags = FESF_GEOS_EXECS;
    fileEnumParams.FEP_returnAttrs = (void*) FESRT_NAME;  /*Return the file's Geos filename.*/
    fileEnumParams.FEP_returnSize = FILE_LONGNAME_BUFFER_SIZE;
    fileEnumParams.FEP_bufSize = FE_BUFSIZE_UNLIMITED;    /* FE_BUFSIZE_UNLIMITED allows the return buffer size to be as large as necessary.*/
    fileEnumParams.FEP_matchAttrs = 0;  /* Set matchAttrs to zero so it will match anything.*/
    fileEnumParams.FEP_skipCount = 0;   /* Don't skip any files*/
    fileEnumParams.FEP_callback = 0;   /* Don't need no callback. */

    numOfFiles = FileEnum(
        &fileEnumParams,
        FilesToReturn,
        &filesNotHandled
    );

    if (numOfFiles && (*FilesToReturn))
    {
        return(numOfFiles);
    }

    return(0);
}

/*-------------------------------------------------------------------
count app in folder
numOfFiles returned
-------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_COUNT_APPS_IN_FOLDER
{
    FileEnumParams       fileEnumParams;
    word                 numOfFiles = NULL;

    fileEnumParams.FEP_searchFlags = FESF_GEOS_EXECS;
    fileEnumParams.FEP_returnAttrs = (void*) FESRT_COUNT_ONLY;  /*Return the file's Geos filename.*/
    fileEnumParams.FEP_returnSize = 0;
    fileEnumParams.FEP_bufSize = FE_BUFSIZE_UNLIMITED;    /* FE_BUFSIZE_UNLIMITED allows the return buffer size to be as large as necessary.*/
    fileEnumParams.FEP_matchAttrs = 0;  /* Set matchAttrs to zero so it will match anything.*/
    fileEnumParams.FEP_skipCount = 0;   /* Don't skip any files*/
    fileEnumParams.FEP_callback = 0;   /* Don't need no callback. */

    (void) FileEnum(&fileEnumParams, NullHandle, &numOfFiles);
    return numOfFiles;
}


/*------------------------------------------------------------------
This is called by MSG_META_DETACH and allows for changing the
name of the state file which should be created for the application.
We don't want no state file, so we just return 0.
------------------------------------------------------------------*/
@method TrayAppsProcessClass, MSG_GEN_PROCESS_CREATE_NEW_STATE_FILE
{
    return 0;
}
