/**************************************************************************
 *	Project: IconEdit file manager tool
 *
 *	File:	tokenlist.goc
 *
 *		All routines and handlers, that deal with the token list,
 *		displayed to the user
 *
 *	By RABE-Soft, Rainer Bettsteller, for Free PC/GEOS Project
 *
 **************************************************************************/

@include <stdapp.goh>
@include <token.h>

@include "foldered.goh"
@include "UI/fedui.goh"

extern optr g_dialog;

extern	MemHandle 	g_tokenList = 0;	/* List of all Tokens in the TokenDB */
extern	GeodeToken	g_selectedToken;
extern	word		g_displaySize;
extern	word		g_tokenStyle;

/*############################################################################
 *
 *	Create and manage TokenList strcutre
 *
 *############################################################################*/


/*-------------------------------------------------------------
 * FEDListTokens
 *-------------------------------------------------------------
 *	Create al list of all tokens in the tokenDB
 *	Return: Number of tokens in TokenDB
-------------------------------------------------------------*/
word FEDListTokens(void) {
TokenListStruct	*list;
dword	retVal;
word count, minIdx, topIdx, n;


    if (g_tokenList) MemFree(g_tokenList);	// Destroy old list

	/*
	 *	6 byte header to use TokenListStruct for access
	 */
    retVal = TokenListTokens(TRF_ONLY_GSTRING, 6, 0);
    g_tokenList = TokenListTokensHandleFromDWord(retVal);
    if( !g_tokenList ) return 0;			// BAD	
    count = TokenListTokensCountFromDWord(retVal);
    
    list = MemLock(g_tokenList);
    list->tokenCount = count;
    list->firstIndex = 0;
    list->tokensToShow = count;
    
	/*
	* Sort list by Manufacturer ID
	* topIdx: 	start of the unsorted list part
	* minIdx:	index of smallest token ID in unsorted list part 
	*/
    for (topIdx = 0; topIdx<(count-1); topIdx++) {
	
	minIdx = topIdx;	// assume: smalles ID is on top
	
	// check all following tokens to see if the ID is smaller
	// find the index of the smallest token ID
	for ( n = topIdx+1; n < count; n++) {
	    if (list->token[n].GT_manufID < list->token[minIdx].GT_manufID) minIdx = n;
	    }
    
    	if (minIdx != topIdx) {
    	    // smaller ID found. swap tokens
    	    GeodeToken tmpToken = list->token[topIdx];
    	    list->token[topIdx] = list->token[minIdx];
    	    list->token[minIdx] = tmpToken;
    	    }
    }

    MemUnlock(g_tokenList);
	
    return count;	
	
}



/*############################################################################
 *
 *	Handlers
 *
 *############################################################################*/
 
/*-------------------------------------------------------------
 * MSG_FED_QUERY_TOKEN_LIST	
 *-------------------------------------------------------------
 *	void GEN_DYNAMIC_LIST_QUERY_MSG (optr list, word item);
 *	Update item moniker in the file list
-------------------------------------------------------------*/
// stop in foldered::FolderEdInteractionFED_QUERY_TOKEN_LIST
@extern method FolderEdInteractionClass, MSG_FED_QUERY_TOKEN_LIST {
TokenListStruct	*tokenList;
GeodeToken tok;

MemHandle  mh;
word 	sizeRead;
Boolean isGString;


@if 0
/*--------------------- InternalGetTokenMonikerBlock ---------------------
 * Purpose:	Get the moniker in a memory block
 * Pass		dispSize DS_TINY  0
 *			DS_STANDARD  1
 *			DS_LARGE  2
 *			DS_HUGE  3
 *		style	VMS_TEXT  0
 *			VMS_ABBREV_TEXT  1
 *			VMS_GRAPHIC_TEXT  2
 *			VMS_ICON  3
 *			VMS_TOOL  4
 * 		*sizeRead: return: bytes read
 *		*isGString: TRUE if GString
 * Return:	Handle of memory block containing the moniker image
 ---------------------------------------------------------------------------*/
MemHandle InternalGetTokenMonikerBlock(GeodeToken token, word dispSize, word style, 
				word *sizeRead, Boolean *isGString) {
@endif
@if 0
	if ( mh ) {
		@call ReleaseLauncherMiniTokenDisplay::MSG_GEN_REPLACE_VIS_MONIKER(
				VUM_NOW, 30, 48, monikerSize,
				VMDT_VIS_MONIKER, VMST_FPTR,
				(dword)MemLock(mh) );
		MemFree(mh);
		}
	else {
		// Kein Mini-Moniker: Kreuz darstellen
		@call ReleaseLauncherMiniTokenDisplay::MSG_GEN_REPLACE_VIS_MONIKER_TEXT("X",0);
		}
@endif		



    tokenList = MemLock(g_tokenList);
    tok = tokenList->token[item + tokenList->firstIndex];
    MemUnlock(g_tokenList);
    
    
    
@if 1
/*
@message void MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(@stack
		word item, ReplaceItemMonikerFlags flags, 
		word height, word width, word length,
		VisMonikerDataType dataType,
		VisMonikerSourceType sourceType,
		dword source);
*/


    mh = InternalGetTokenMonikerBlock(tok, g_displaySize, g_tokenStyle, &sizeRead, &isGString);
    

	if ( mh ) {
		@call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(item, 
				0,30,48,sizeRead,
				VMDT_VIS_MONIKER ,VMST_FPTR,(dword)MemLock(mh));
		MemFree(mh);
		}
	else {
		@call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, "NOT found");
	}	
	
@endif

{char buf[40];
sprintf(buf, "%u,%u", sizeRead, isGString);
//call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, buf);
}
@if 0
    @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(item,
			0,30,48,0,VMDT_TOKEN,VMST_FPTR,(dword)&tok);
@endif			
}

/*-------------------------------------------------------------
 * MSG_FED_APPLY_TOKEN_LIST
 *-------------------------------------------------------------
 *	GEN_ITEM_GROUP_APPLY_MSG ( word selection = cx,
 * 			    	    word numSelections = bp,
 *				    GenItemGroupStateFlags stateFlags = dl);
 *	
-------------------------------------------------------------*/
// stop in foldered::FolderEdInteractionFED_APPLY_TOKEN_LIST
@extern method FolderEdInteractionClass, MSG_FED_APPLY_TOKEN_LIST {
TokenListStruct	*tokenList;
GeodeToken tok;

    tokenList = MemLock(g_tokenList);
    tok = tokenList->token[selection + tokenList->firstIndex];
    g_selectedToken = tok;
    MemUnlock(g_tokenList);


    FEDShowToken(tok, @DialogObj(@TokenNewID), @DialogObj(@TokenNewDisplay), 0);
    // µµ check, ob TRT_NONE (statt NUll) hier OK ist

    /* Redraw TokenGroup to remove possible artefacts */
    @call @DialogObj(@FEDTokenGroup)::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE);
    @send @DialogObj(@FEDTokenGroup)::MSG_GEN_SET_USABLE(VUM_NOW);

}

/*-------------------------------------------------------------
 * MSG_FED_APPLY_TOKEN_RANGE
 *-------------------------------------------------------------
 *	
-------------------------------------------------------------*/
// stop in foldered::FolderEdInteractionFED_APPLY_TOKEN_RANGE
@extern method FolderEdInteractionClass, MSG_FED_APPLY_TOKEN_RANGE {
TokenListStruct	*list;
word minID, maxID, n;
Boolean found;

/*
	µµ current selection handling feht noch
	*/

    minID = @call @DialogObj(@FEDManufIDMinimumValue)::MSG_GEN_VALUE_GET_VALUE();
    maxID = @call @DialogObj(@FEDManufIDMaximumValue)::MSG_GEN_VALUE_GET_VALUE();
    if ( minID > maxID ) {
    	word tmp = minID;
    	minID=maxID;
    	maxID=tmp;
	@call @DialogObj(@FEDManufIDMinimumValue)::MSG_GEN_VALUE_SET_VALUE(minID, FALSE);
	@call @DialogObj(@FEDManufIDMaximumValue)::MSG_GEN_VALUE_SET_VALUE(maxID, FALSE);
	}
	
    list = MemLock(g_tokenList);

    do {    
	found = FALSE;
	list->firstIndex = 0;
	list->tokensToShow = 0;
	
	// find first index to display
	for (n = 0; n < list->tokenCount; n++ ) {
	    if (list->token[n].GT_manufID >= minID ) {
		list->firstIndex = n;
		found = TRUE;
		break;
		}
	}
 	if ( !found ) break;		// minID too large
 	
 	// find number of token to display
 	list->tokensToShow = 0;
 	for (n = list->firstIndex; n < list->tokenCount; n++) {
 	    if (list->token[n].GT_manufID > maxID ) break;
 	    list->tokensToShow++;
 	    }
 	
 	} while(FALSE);
    
    // if there are no token to display, list->tokensToShow will be zero
    // --> no extra handling required for the list
    @send @DialogObj(@FEDTokenList)::MSG_GEN_DYNAMIC_LIST_INITIALIZE(list->tokensToShow);
    @send @DialogObj(@FEDIconInfoDisplayed)::MSG_GEN_VALUE_SET_INTEGER_VALUE(list->tokensToShow, FALSE);

    // ... but disable "Change Token" button and clear "new" token
    if (0==list->tokensToShow) {
    	@send @DialogObj(@SelectOkTrigger)::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    	
    	@call @DialogObj(@TokenNewID)::MSG_GEN_REPLACE_VIS_MONIKER_TEXT("",0);
    	@call @DialogObj(@TokenNewDisplay)::MSG_GEN_REPLACE_VIS_MONIKER_TEXT("",0);
    	}
    else {
    	@send @DialogObj(@SelectOkTrigger)::MSG_GEN_SET_ENABLED(VUM_NOW);
    	}


    MemUnlock(g_tokenList);

    /* Redraw TokenGroup to remove possible artefacts */
    @call @DialogObj(@FEDTokenGroup)::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE);
    @send @DialogObj(@FEDTokenGroup)::MSG_GEN_SET_USABLE(VUM_NOW);
/**/
}



/*-------------------------------------------------------------
 * MSG_FED_APPLY_TOKEN_TYPE
 *-------------------------------------------------------------
 *	Select a nee display size and toke style to display in list
-------------------------------------------------------------*/
// stop in foldered::FolderEdInteractionFED_APPLY_TOKEN_TYPE
@extern method FolderEdInteractionClass, MSG_FED_APPLY_TOKEN_TYPE {
TokenListStruct	*list;
word count;

    g_tokenStyle = @call @DialogObj(@FEDTokenStyleSelector)::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    g_displaySize = @call @DialogObj(@FEDDisplaySizeSelector)::MSG_GEN_ITEM_GROUP_GET_SELECTION();
   
    list = MemLock(g_tokenList);
    count = list->tokensToShow;
    MemUnlock(g_tokenList);
    
    @call @DialogObj(@FEDTokenList)::MSG_GEN_DYNAMIC_LIST_INITIALIZE(count);

 
}

