@include <openwith.goh>

/***********************************************************************
Resourcen
***********************************************************************/
@start FMUI, data;

    @visMoniker Moniker1 = "Open With";
    @chunk char errorNoDOSFile[] = "Please select DOS files only.";
    @chunk char errorNoCompatibleApp[] = "The selected application is not compatible with DOS files.";

    @chunkArray GeodeToken BlacklistArray = {
        { "PMGR" , 0 },
        { "BCAL" , 0 },
        { "CLK$" , 0 },
        { "DUMP" , 0 },
        { "PERF" , 0 }
    };

@end FMUI;


@start DialogUI, notDetachable;

    @object OpenWithDialogClass SelectDialog = {
        GI_visMoniker = "Open With";
        GI_comp =   @SelectView,
                    @SelectReplyBar;
        GI_states = (@default & (~GS_USABLE));
        GII_visibility = GIV_DIALOG;
        GII_attrs = @default | GIA_INITIATED_VIA_USER_DO_DIALOG | GIA_MODAL;

        HINT_PLACE_MONIKER_ABOVE;
        HINT_ORIENT_CHILDREN_VERTICALLY;
    }

    @object GenViewClass SelectView = {
        GVI_content = @SelectContent;
        GVI_attrs = @default | GVA_GENERIC_CONTENTS | GVA_DRAG_SCROLLING | GVA_SAME_COLOR_AS_PARENT_WIN;
        GVI_horizAttrs = @default | GVDA_NO_SMALLER_THAN_CONTENT; //GVDA_NO_LARGER_THAN_CONTENT
        GVI_vertAttrs = @default | GVDA_SCROLLABLE;

        HINT_FIXED_SIZE = {
        	SST_PCT_OF_FIELD_WIDTH | PCT_25,
        	SST_PCT_OF_FIELD_HEIGHT | PCT_35,
	        0
        };

        HINT_VIEW_REMOVE_SCROLLERS_WHEN_NOT_SCROLLABLE;
        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    }

    @object OpenWithContentClass SelectContent = {
        GCI_attrs = @default | VCNA_SAME_WIDTH_AS_VIEW;
        GCI_genView = @SelectView;

        HINT_TOOLBOX;
        HINT_CUSTOM_CHILD_SPACING = {SST_PIXELS | 0};
        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    }

    @object GenInteractionClass SelectReplyBar ={
        GI_comp =   @SelectCancelTrigger,
                    @ConfigureDialog;

        HINT_MAKE_REPLY_BAR;
    }

    @object GenTriggerClass SelectCancelTrigger = {
        ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_DISMISS };

        HINT_SEEK_REPLY_BAR;
    }


    @object ConfigureDialogClass ConfigureDialog = {
        GI_visMoniker = "Configure";
        GI_comp =       @OpenWithGroup,
                        @ConfigureReplyBar;

        GII_visibility = GIV_DIALOG;
        GII_attrs = @default | GIA_MODAL;

        HINT_PLACE_MONIKER_ABOVE;
        HINT_ORIENT_CHILDREN_HORIZONTALLY;
        HINT_SEEK_REPLY_BAR;
        HINT_DEFAULT_DEFAULT_ACTION;
    }

    @object GenInteractionClass OpenWithGroup = {
        GI_visMoniker = "Open With";
        GI_comp =	@AddAppSelector,
                    @AddAppTrigger,
                    @OpenWithAppListGroup;

        HINT_DRAW_IN_BOX;
        HINT_PLACE_MONIKER_ABOVE;
        HINT_ORIENT_CHILDREN_HORIZONTALLY;
        HINT_CENTER_CHILDREN_VERTICALLY;
    }

    @object GenFileSelectorClass AddAppSelector = {
        GFSI_attrs =           ((FSA_ALLOW_CHANGE_DIRS) & (~FSA_SHOW_FILES_DISABLED) & (~FSA_HAS_OPEN_DIR_BUTTON) & (~FSA_HAS_CHANGE_DIRECTORY_LIST))
                                | ((FSA_HAS_FILE_LIST) & (~FSA_SHOW_FIXED_DISKS_ONLY) & (~FSA_HAS_CLOSE_DIR_BUTTON) & (~FSA_HAS_DOCUMENT_BUTTON)& (~FSA_HAS_CHANGE_DRIVE_LIST))
                                | ((FSA_USE_VIRTUAL_ROOT));

        GFSI_fileCriteria =      ((FSFC_DIRS) & (~FSFC_NON_GEOS_FILES))
                                | ((FSFC_GEOS_EXECUTABLES) & (~FSFC_GEOS_NON_EXECUTABLES));

        ATTR_GEN_FILE_SELECTOR_VIRTUAL_ROOT = {SP_APPLICATION, ""};
        ATTR_GEN_PATH_DATA = {SP_APPLICATION, ""};
        HINT_FILE_SELECTOR_FILE_LIST_WIDTH = 33;
        HINT_FILE_SELECTOR_NUMBER_OF_FILES_TO_SHOW = 10;
    }

    @object GenTriggerClass AddAppTrigger = {
        GI_visMoniker = "=>";
        GTI_destination = @OpenWithAppList;
        GTI_actionMsg = MSG_ADD_APP;
    }

    @object GenInteractionClass OpenWithAppListGroup = {
        GI_comp =   @OpenWithAppList,
                    @RemoveAppTrigger;

        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_CENTER_CHILDREN_HORIZONTALLY;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    }

    @object AppDynamicListClass OpenWithAppList = {
        GIGI_destination = (TO_SELF);
        GIGI_behaviorType = GIGBT_EXCLUSIVE;
        //GIGI_behaviorType = GIGBT_NON_EXCLUSIVE;
        GDLI_queryMsg = MSG_QUERY_APP_MONIKER;

        HINT_ITEM_GROUP_SCROLLABLE;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
        HINT_FIXED_SIZE = {SST_AVG_CHAR_WIDTHS | 33};

        /*
        HINT_FIXED_SIZE {
            SpecWidth <SST_AVG_CHAR_WIDTHS, 24>
            SpecHeight <SST_LINES_OF_TEXT, 3>
            word	3
        },
        */
        // ATTR_GEN_ITEM_GROUP_STATUS_MSG = (word )MSG_SL_STARTUP_PROGRAM_SELECTED;
    }

    @object GenTriggerClass RemoveAppTrigger = {
        GI_visMoniker = "Remove";

        GTI_destination = @OpenWithAppList;
        GTI_actionMsg = MSG_REMOVE_APP;

        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    }

    @object GenInteractionClass ConfigureReplyBar ={
        GI_comp =   @ConfigureOkTrigger,
                    @ConfigureCancelTrigger;

        HINT_MAKE_REPLY_BAR;
    }

    @object GenTriggerClass ConfigureOkTrigger = {
        GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
        GTI_actionMsg = MSG_CLOSE_CONFIGURE_DIALOG;
        GTI_destination = @ConfigureDialog;

        HINT_SEEK_REPLY_BAR;
        ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_APPLY };
        HINT_DEFAULT_DEFAULT_ACTION;
    }

    @object GenTriggerClass ConfigureCancelTrigger = {
        ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_DISMISS };
        HINT_SEEK_REPLY_BAR;
    }


@end DialogUI;


/**************************************************************
dgroup
**************************************************************/
//API Struct - MUST be global
FMToolStruct FMToolInfo[1] = {
    {
        @Moniker1, (FMTF_SELECTED_ONLY | FMTT_DIALOG), 1
    }
};

optr    appList = NullOptr;
#define TOOL_ICON_WIDTH         15
#define TOOL_ICON_HEIGHT        15
#define TOOL_ICON_FLAGS         ((VMSF_GSTRING) | (VMS_TOOL << VMSF_STYLE_OFFSET))


/**************************************************************
FileManager API Function - fetch Tools
**************************************************************/
//FMFetchToolsProc GetThoseTools
word _pascal _export GetThoseTools(FMToolStruct **tablePtr)
{
    *tablePtr = (FMToolStruct*) &FMToolInfo;
    return 1;
}

/**************************************************************
The user has clicked on our Utilities menu item: "Open With"
GeodeHandle filemgr => Process that is subclass of FileManagerClass
word toolNum =>	Entry # of activated tool within table returned by
                FMTF_FETCH_TOOLS
word entryNum
***************************************************************/
//FMToolProc OpenWithEntryPoint()
void _pascal _export OpenWithEntryPoint(
    GeodeHandle filemgr,
    word toolNum,
    word entryNum
)
{
    MemHandle                   selFiles;
    InteractionCommand          reply = IC_NULL;
    optr                        dialog = NullOptr;
    optr                        fSelect = NullOptr;
    dword	    	            flagsAndDisk;	/* entry flags + disk handle returned by file selector */
    char    	                pathnameAndFile[PATH_BUFFER_SIZE + FILE_LONGNAME_BUFFER_SIZE];   	/* Buffer for fetching the complete path of the application */
    DiskHandle  	            disk;	    	/* Disk on which it resides */
    GeodeToken  	            token;	    	/* Token for the application, so we can connect to it */

    // check for non-DOS files, folders, etc. first
    selFiles = @call ConstructOptr(filemgr, 0)::MSG_FM_GET_SELECTED_FILES();
    if (CheckIfUnsupportedFiles(selFiles)) // true on ERROR
    {
        UserStandardDialogOptr(
            0, 0, 0, 0,
            @errorNoDOSFile,
            ((CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
             (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET))
        );
        return;
    }

    // we assume just DOS files in the list as of now and bring up the dialogue
    dialog = @call ConstructOptr(filemgr, 0)::MSG_FM_DUP_AND_ADD(@SelectDialog, FMP_APPLICATION);
    @call dialog::MSG_GEN_SET_USABLE(VUM_NOW);
    reply = UserDoDialog(dialog);

    if (reply == IC_OK)
    {
        fSelect = @call dialog::MSG_GEN_FIND_CHILD_AT_POSITION(0);
        flagsAndDisk = @call fSelect::MSG_GEN_FILE_SELECTOR_GET_FULL_SELECTION_PATH(&pathnameAndFile);

        if (GFS_GET_ENTRY_TYPE(flagsAndDisk) == GFSET_FILE)
        {
            disk = GFS_GET_FULL_SELECTION_PATH_DISK_HANDLE(flagsAndDisk); // Extract disk handle

            FilePushDir();
            if (
                 (FileSetCurrentPath(disk, _TEXT("\\")) != 0) &&
                 (FileGetPathExtAttributes(pathnameAndFile, FEA_TOKEN, &token, sizeof(token)) == 0)
               )
            {
                if (IsAppOnBlacklist(&token))
                {
                    UserStandardDialogOptr(
                        0, 0, 0, 0,
                        @errorNoCompatibleApp,
                        ((CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
                        (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET))
                    );
                    return;
                }

                selFiles = @call ConstructOptr(filemgr, 0)::MSG_FM_GET_SELECTED_FILES();
                LoadFiles(&token, disk, &pathnameAndFile, selFiles);
            }
            FilePopDir();
        }
    }

    UserDestroyDialog(dialog);
}


/**************************************************************
check if unsupported file
**************************************************************/
Boolean CheckIfUnsupportedFiles(MemHandle selFiles)
{
    MemHandle                   oldBlock;
    FileQuickTransferHeader*    headerPtr;
    FileOperationInfoEntry*     entriesPtr;
    word                        i;
    Boolean                     hadError = FALSE;
    FileAttrs                   fAttrs;

    while (selFiles != 0)
    {
        headerPtr  = (FileQuickTransferHeader*) MemLock(selFiles); // get pointer to it header
        entriesPtr = (FileOperationInfoEntry*) (headerPtr + 1); // get pointer to first entry (follows header)

        for (i=0; i < headerPtr->FQTH_numFiles; i++)
        {
            if ((entriesPtr->FOIE_type == GFT_NOT_GEOS_FILE) &&
                (entriesPtr->FOIE_type != GFT_DIRECTORY))
            {
                // for folders above DOCUMENT/WORLD GFT_DIRECTORY seems not to be set (...?) -
                // so we check again if actually a folder
                FilePushDir();
                if (FileSetCurrentPath(headerPtr->FQTH_diskHandle, headerPtr->FQTH_pathname) != NullHandle)
                {
                    fAttrs = FileGetAttributes(entriesPtr->FOIE_name);
                    if ((fAttrs & FA_SUBDIR) ||
                        (fAttrs & FA_VOLUME) ||
                        (fAttrs & FA_SYSTEM) ||
                        (fAttrs & FA_HIDDEN) ||
                        (fAttrs & FA_RDONLY))
                    {
                        FilePopDir();
                        hadError = TRUE;
                        break;
                    }
                }
                else
                {
                    FilePopDir();
                    hadError = TRUE;
                    break;
                }
                FilePopDir();
            }
            else
            {
                hadError = TRUE;
                break;
            }

            // point to the next entry
            entriesPtr = (FileOperationInfoEntry*) entriesPtr + 1;
        }

        if (hadError)
        {
            MemUnlock(selFiles);
            MemFree(selFiles);
            break;
        }
        else
        {
            // get next block, if any
            MemUnlock(selFiles);
            oldBlock = selFiles;
            selFiles = headerPtr->FQTH_nextBlock; // returns 0 if end, which breaks the loop
            MemFree(oldBlock);
        }
    }

    return hadError;
}

/**************************************************************
is app on blacklist?
**************************************************************/
Boolean IsAppOnBlacklist(GeodeToken* appToken)
{
    word            numApps = 0;
    GeodeToken*     listApp = (void*) 0;
    word            size = 0;
    word            i = 0;
    Boolean         isOnList = FALSE;

    MemLock(HandleOf(@BlacklistArray));
    numApps = ChunkArrayGetCount(@BlacklistArray);

    for (i = 0; i < numApps; i++)
    {
        listApp = ChunkArrayElementToPtr(@BlacklistArray, i, &size);

        if ((appToken->GT_chars[0] == listApp->GT_chars[0]) &&
            (appToken->GT_chars[1] == listApp->GT_chars[1]) &&
            (appToken->GT_chars[2] == listApp->GT_chars[2]) &&
            (appToken->GT_chars[3] == listApp->GT_chars[3]) &&
            (appToken->GT_manufID  == listApp->GT_manufID))
        {
            isOnList = TRUE;
            break;
        }
    }

    MemUnlock(HandleOf(@BlacklistArray));

    return isOnList;
}

/**************************************************************
load files one by one
**************************************************************/
void LoadFiles(GeodeToken* token, DiskHandle disk, char* pathnameAndFile, MemHandle selFiles)
{
MemHandle                   oldBlock;
FileQuickTransferHeader*    headerPtr;
FileOperationInfoEntry*     entriesPtr;
word                        i;

    while (selFiles != 0)
    {
        headerPtr  = (FileQuickTransferHeader*) MemLock(selFiles); // get pointer to it header
        entriesPtr = (FileOperationInfoEntry*) (headerPtr + 1); // get pointer to first entry (follows header)

        for (i=0; i < headerPtr->FQTH_numFiles; i++)
        {
            LaunchApp(
                token,
                disk,
                pathnameAndFile,
                headerPtr->FQTH_diskHandle,
                headerPtr->FQTH_pathname,
                entriesPtr->FOIE_name
            );

            // point to the next entry
            entriesPtr = (FileOperationInfoEntry*) entriesPtr + 1;
        }

        // get next block, if any
        MemUnlock(selFiles);
        oldBlock = selFiles;
        selFiles = headerPtr->FQTH_nextBlock; // returns 0 if end, which breaks the loop
        MemFree(oldBlock);
    }
}

/**************************************************************
launch application with DOS file via IACP...
**************************************************************/
void LaunchApp(
    GeodeToken *appTok,
    DiskHandle appDisk,
    char *appPath,
    DiskHandle dataDisk,
    PathName *dataPath,
    FileLongName *dataFName)
{
    IACPConnection       iacpConnectionToken = IACP_NO_CONNECTION;
    word                 connectionFlags = IACPSM_USER_INTERACTIBLE | IACPCF_FIRST_ONLY;
    word                 serverCount;
    MemHandle            albBlock;
    AppLaunchBlock       *albPtr;

    albBlock = IACPCreateDefaultLaunchBlock(MSG_GEN_PROCESS_OPEN_APPLICATION);

    albPtr = MemLock(albBlock);
    strcpy(albPtr->ALB_appRef.AIR_fileName, appPath);
    albPtr->ALB_appRef.AIR_diskHandle = appDisk;
    albPtr->ALB_diskHandle = dataDisk;
    strcpy(albPtr->ALB_path, dataPath);
    strcpy(albPtr->ALB_dataFile, dataFName);
    MemUnlock(albBlock);

    iacpConnectionToken = IACPConnect(appTok, connectionFlags, albBlock, NullOptr, &serverCount);
    if(iacpConnectionToken != IACP_NO_CONNECTION)
    {
        IACPShutdown(iacpConnectionToken, NullOptr);
    }
}

/********************************************************************

********************************************************************/
Boolean checkIfInList(optr list, char* appName, word listLen)
{
    word    i = 0;
    char*   str = (char*) 0;
    word    elSize = 0;

    // list must be locked!
    for (i=0; i < listLen; i++)
    {
        str = (char*) ChunkArrayElementToPtr(list, i, &elSize);
        if (strstr(str, appName))
        {
            return TRUE;
        }
    }

    return FALSE;
}

/********************************************************************

********************************************************************/
void readAppsFromIniFile()
{
    MemHandle       mh = NullHandle;
    ChunkHandle     ch = NullChunk;
    optr            ourList = NullOptr;

    if (mh != NullHandle) MemFree(mh);
    mh = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    MemLock(mh);

    ch = ChunkArrayCreate(mh, sizeof(PathName) + sizeof(FileLongName), 0, 0);

    appList = ConstructOptr(mh, ch);
    ourList = appList;

    InitFileEnumStringSection(
        _TEXT("fileManager"),
        _TEXT("openWith"),
        IFRF_READ_ALL,
        ReadAppsCallback,
        (void*) &ourList);

    MemUnlock(mh);
}

/********************************************************************

********************************************************************/
Boolean ReadAppsCallback(const char *stringSection, word sectionNum, void* enumData)
{
    char* str;

    str = (char*) ChunkArrayAppend(*((optr*) enumData), 0); // convert VOID-Pointer to OPTR-Pointer and deref afterwards...
    strcpy(str, stringSection);

    return FALSE; // no error
}

/********************************************************************

********************************************************************/
void writeIniFile()
{
    word    i = 0;
    char*   str = (char*) 0;
    word    elSize = 0;
    word    listLen = 0;

    InitFileDeleteEntry(_TEXT("fileManager"), _TEXT("openWith"));

    MemLock(HandleOf(appList));
    listLen = ChunkArrayGetCount(appList);

    // list must be locked!
    for (i = 0; i < listLen; i++)
    {
        str = (char*) ChunkArrayElementToPtr(appList, i, &elSize);
	    InitFileWriteStringSection(
            _TEXT("fileManager"),
            _TEXT("openWith"),
            str
        );
    }

    InitFileCommit();
    MemUnlock(HandleOf(appList));
}


/********************************************************************
Classes & Methods
********************************************************************/


/********************************************************************

********************************************************************/
@method OpenWithDialogClass, MSG_GEN_INTERACTION_INITIATE
{
    readAppsFromIniFile();
    @callsuper();
}

/********************************************************************

********************************************************************/
@method GeodeTokenTriggerClass, MSG_APP_TRIGGER_PRESSED
{
    GeodeToken  gt;
    char        fname[PATH_BUFFER_SIZE * FILE_LONGNAME_BUFFER_SIZE];

    @call @dup(trigger)::MSG_META_GET_VAR_DATA(ATTR_GEODE_TOKEN_TO_PASS, sizeof(GeodeToken), &gt);
    @call @dup(trigger)::MSG_META_GET_VAR_DATA(ATTR_GEODE_FILE_NAME, sizeof(FileLongName), &fname);

    UserStandardDialog(
        0, 0, 0, 0,
        _TEXT("WHUT?"),
        ((CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
        (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET))
    );
}


/********************************************************************

********************************************************************/
@method OpenWithContentClass, MSG_SPEC_BUILD
{
    @callsuper();

    @call oself::MSG_BUILD_TRIGGERS();
}

/********************************************************************

********************************************************************/
@method OpenWithContentClass, MSG_BUILD_TRIGGERS
{

    DisplayScheme	    ds;
    optr                triggerObj = NullOptr;
    Boolean             monikerFound = FALSE;
    MemHandle           newMoniker = NULL;
    word                monikerSize = 0;
    ChunkHandle         combinedMoniker = NullChunk;
    GeodeToken          tok;
    char*               filePtr = (void*) 0;
    byte                triggerNo = 0;
    MemHandle           triggerBlock = NullHandle;
    VisMonikerWithGString*         vmp = (void*) 0;
    word                width = 0;
    word                height = 0;
    ChunkHandle         helpChunk = NullHandle;
    optr                helpOptr = NullOptr;
    word                num = 0;
    word                elSize = 0;

    ChunkHandle         textMoniker;
    ChunkHandle         iconMoniker;
    word                chunkSize;


    @call oself::MSG_REMOVE_ALL_APP_TRIGGERS();

    MemLock(HandleOf(appList));
    num = ChunkArrayGetCount(appList);

    if (num > 0)
    {
        for (triggerNo=0; triggerNo < num; triggerNo++)
        {
            width = 0;
            height = 0;

            FilePushDir();
            FileSetStandardPath(SP_APPLICATION);
            filePtr = (char*) ChunkArrayElementToPtr(appList, triggerNo, &elSize);
            FileGetPathExtAttributes(filePtr, FEA_TOKEN, (&tok), sizeof(GeodeToken));
            FilePopDir();

            triggerBlock = OptrToHandle(oself);
            triggerObj = ObjInstantiate(triggerBlock, &GeodeTokenTriggerClass);

            if (triggerObj != NullOptr)
            {
                @call oself::MSG_GEN_ADD_CHILD(triggerObj, CCO_LAST);


                //  // trying to create a combined moniker
                // ObjLockObjBlock(HandleOf(triggerObj));
                // monikerFound = TokenLoadMonikerChunk(
                //     TOKEN_CHARS(tok.GT_chars[0],tok.GT_chars[1],tok.GT_chars[2],tok.GT_chars[3]),
                //     tok.GT_manufID,
                //     0,
                //     (VMSF_COPY_CHUNK | (VMS_TEXT << VMSF_STYLE_OFFSET)),
                //     HandleOf(triggerObj),
                //     &chunkSize,
                //     &textMoniker
                // );
                // @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&ds);
                // monikerFound = TokenLoadMonikerChunk(
                //     TOKEN_CHARS(tok.GT_chars[0],tok.GT_chars[1],tok.GT_chars[2],tok.GT_chars[3]),
                //     tok.GT_manufID,
                //     ds.DS_displayType,
                //     TOOL_ICON_FLAGS,
                //     HandleOf(triggerObj),
                //     &chunkSize,
                //     &iconMoniker
                // );
                // if (monikerFound)
                // {
                //     vmp = (VisMonikerWithGString*) MemLock(newMoniker);
                //     if (vmp->VMWGS_common.VM_type & VMT_GSTRING)
                //     {
                //         width = vmp->VMWGS_common.VM_width;
                //         height = vmp->VMWGS_height;
                //     }
                //     MemUnlock(newMoniker);
                // }
                // if ((monikerFound) && (height <= TOOL_ICON_HEIGHT) && (width <= TOOL_ICON_WIDTH))
                // {
                //     typedef WordFlags CreateIconTextMonikerFlags;
                //     #define CITMF_POSITION_ICON_ABOVE_TEXT	0x8000
                //     #define CITMF_TEXT_IS_FPTR		0x4000
                //     #define CITMF_CREATE_CHUNK		0x2000
                //     #define CITMF_SWAP_ICON_TEXT            0x1000
                //     #define CITMF_POSITION_ICON_BELOW_TEXT 0x9000
                //     #define CITMF_POSITION_ICON_RIGHT_OF_TEXT 0x1000
                //     extern optr _pascal UserCreateIconTextMoniker(optr textMoniker,
                //                         optr iconMoniker,
                //                         Handle destinationBlock,
                //                         word spacing,
                //                         CreateIconTextMonikerFlags flags);
                //     combinedMoniker = UserCreateIconTextMoniker(
                //         @errorNoDOSFile,
                //         (ConstructOptr(newMoniker, 0)),
                //         newMoniker,
                //         (word) 7,
                //         0
                //     );
                //     combinedMoniker = UserCreateIconTextMoniker(
                //         (ConstructOptr(HandleOf(triggerObj), textMoniker)),
                //         (ConstructOptr(HandleOf(triggerObj), iconMoniker)),
                //         NullHandle,
                //         0,
                //         CITMF_CREATE_CHUNK
                //     );
                //     MemUnlock(HandleOf(triggerObj));
                //     @call triggerObj::MSG_GEN_REPLACE_VIS_MONIKER(
                //         VUM_NOW,
                //         0, 0, monikerSize,
                //         VMDT_VIS_MONIKER,
                //         VMST_HPTR,
                //         ConstructOptr(triggerBlock, combinedMoniker)
                //     );
                // }
                //  else
                {
                    @call triggerObj::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(filePtr, VUM_NOW);
                }

                if (monikerFound) MemFree(newMoniker);

                // set up some common stuff
                @call triggerObj::MSG_GEN_TRIGGER_SET_ACTION_MSG(MSG_APP_TRIGGER_PRESSED);
               //@call triggerObj::MSG_GEN_TRIGGER_SET_DESTINATION(triggerObj);

                @call triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_TOKEN_TO_PASS & (~VDF_SAVE_TO_STATE)), sizeof(GeodeToken), &tok);
                @call triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_FILE_NAME & (~VDF_SAVE_TO_STATE)), sizeof(FileLongName), filePtr);

                @call triggerObj::MSG_META_ADD_VAR_DATA((HINT_EXPAND_WIDTH_TO_FIT_PARENT & (~VDF_SAVE_TO_STATE)), 0, 0);

                // add bubble help
                // MemLock(OptrToHandle(@TrayAppsFolderName)); // get handle of STRINGS resource
                // helpChunk = LMemAlloc(OptrToHandle(@TrayAppsFolderName), FILE_LONGNAME_BUFFER_SIZE); // allocate new chunk in resource
                // strcpy(LMemDerefHandles(OptrToHandle(@TrayAppsFolderName), helpChunk), filePtr);
                // MemUnlock(OptrToHandle(@TrayAppsFolderName));
                // helpOptr = ConstructOptr(OptrToHandle(@TrayAppsFolderName), helpChunk);
                // @call triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEN_FOCUS_HELP & (~VDF_SAVE_TO_STATE)), sizeof(optr), &helpOptr);

                //finally, set usable
                @call triggerObj::MSG_GEN_SET_USABLE(VUM_NOW);
            }
        }
    }

    MemUnlock(HandleOf(appList));
}

/*-------------------------------------------------------------------
remove all our triggers from SysTray
-------------------------------------------------------------------*/
@method OpenWithContentClass, MSG_REMOVE_ALL_APP_TRIGGERS
{
    optr    trigger = NullOptr;

    while(TRUE)
    {
        trigger = @call oself::MSG_GEN_FIND_CHILD_AT_POSITION(0);
        if (trigger == NullOptr) break;
        @call trigger::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
        @call oself::MSG_GEN_REMOVE_CHILD(trigger, CCF_MARK_DIRTY);
        @call trigger::MSG_META_OBJ_FREE();
    }
}

/********************************************************************

********************************************************************/
@method ConfigureDialogClass, MSG_GEN_INTERACTION_INITIATE
{
    word    num = 0;

    @callsuper();

    MemLock(HandleOf(appList));
    num = ChunkArrayGetCount(appList);
    MemUnlock(HandleOf(appList));
    @call @dup(@OpenWithAppList)::MSG_GEN_DYNAMIC_LIST_INITIALIZE(num);
    @call @dup(@OpenWithAppList)::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(TRUE);
}


/********************************************************************

********************************************************************/
@method ConfigureDialogClass, MSG_CLOSE_CONFIGURE_DIALOG
{
    word    num = 0;

    writeIniFile();
    @call @dup(@SelectContent)::MSG_BUILD_TRIGGERS();

    @callsuper();
}


/********************************************************************
// (optr list, word item);
********************************************************************/
@method	AppDynamicListClass, MSG_QUERY_APP_MONIKER
{
    char*   str = (void*) 0;
    word    elSize = 0;

    MemLock(HandleOf(appList));
    str = (char*) ChunkArrayElementToPtr(appList, item, &elSize);
    @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, str);
    MemUnlock(HandleOf(appList));
}


/********************************************************************

********************************************************************/
@method	AppDynamicListClass, MSG_ADD_APP
{
    word                        num = 0;
    char*                       str = (char*) 0;
    dword                       flagsAndDisk;
    char    	                pathnameAndFile[PATH_BUFFER_SIZE + FILE_LONGNAME_BUFFER_SIZE] = {0};   	/* Buffer for fetching the complete path of the application */

    flagsAndDisk = @call @dup(@AddAppSelector)::MSG_GEN_FILE_SELECTOR_GET_FULL_SELECTION_PATH(&pathnameAndFile);

    if (GFS_GET_ENTRY_TYPE(flagsAndDisk) == GFSET_FILE)
    {
        if (strlen(pathnameAndFile) > 0)
        {
            MemLock(HandleOf(appList));

            num = ChunkArrayGetCount(appList);
            if (checkIfInList(appList, pathnameAndFile, num) == FALSE)
            {
                str = (char*) ChunkArrayAppend(appList, 0);
                strcpy(str, pathnameAndFile);

                num = ChunkArrayGetCount(appList);
                @call oself::MSG_GEN_DYNAMIC_LIST_INITIALIZE(num);
                @call oself::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(TRUE);
            }

            MemUnlock(HandleOf(appList));
        }
    }
}

/********************************************************************

********************************************************************/
@method	AppDynamicListClass, MSG_REMOVE_APP
{
    word                        idx = 0;
    word                        num = 0;

	idx = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();

    MemLock(HandleOf(appList));

	ChunkArrayDeleteRange(appList, idx, 1);
    num = ChunkArrayGetCount(appList);
    @call oself::MSG_GEN_DYNAMIC_LIST_INITIALIZE(num);
    @call oself::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(TRUE);

    MemUnlock(HandleOf(appList));
}
