@include <openwith.goh>

/***********************************************************************
Resourcen
***********************************************************************/
@start FMUI, data;

    @visMoniker ToolNameMoniker = "Open With";
    @chunk char errorNoDOSFile[] = "Please select DOS files only.";
    @chunk char errorNoCompatibleApp[] = "The selected application is not compatible with DOS files.";

    @chunkArray GeodeToken BlacklistArray = {
        { "PMGR" , 0 },
        { "BCAL" , 0 },
        { "CLK$" , 0 },
        { "DUMP" , 0 },
        { "PERF" , 0 }
    };

@end FMUI;


@start DialogUI, notDetachable;

    @include "Art/mkrRightArrowSC.goh"
    @include "Art/mkrLeftArrowSC.goh"
    @visMoniker addAppTriggerTextMoniker = "Add";
    @visMoniker removeAppTriggerTextMoniker = "Remove";

    @object OpenWithDialogClass SelectDialog = {
        GI_visMoniker = "Open With";
        GI_comp =   @SelectView,
                    @SelectReplyBar;
        GI_states = (@default & (~GS_USABLE));
        GII_visibility = GIV_DIALOG;
        GII_attrs = @default | GIA_INITIATED_VIA_USER_DO_DIALOG | GIA_MODAL;

        HINT_PLACE_MONIKER_ABOVE;
        HINT_ORIENT_CHILDREN_VERTICALLY;
    }

    @object GenViewClass SelectView = {
        GVI_content = @SelectContent;
        GVI_attrs = @default | GVA_GENERIC_CONTENTS | GVA_DRAG_SCROLLING | GVA_SAME_COLOR_AS_PARENT_WIN;
        GVI_horizAttrs = @default | GVDA_NO_SMALLER_THAN_CONTENT; // GVDA_NO_LARGER_THAN_CONTENT
        GVI_vertAttrs = @default | GVDA_SCROLLABLE;

        HINT_FIXED_SIZE = {
        	SST_PCT_OF_FIELD_WIDTH | PCT_25,
        	SST_PCT_OF_FIELD_HEIGHT | PCT_35,
	        0
        };

        HINT_VIEW_REMOVE_SCROLLERS_WHEN_NOT_SCROLLABLE;
        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    }

    @object OpenWithContentClass SelectContent = {
        //GI_comp = @DummyTrigger;
        GCI_attrs = @default | VCNA_SAME_WIDTH_AS_VIEW;
        GCI_genView = @SelectView;

        HINT_TOOLBOX;
        HINT_CUSTOM_CHILD_SPACING = {SST_PIXELS | 0};
        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    }

    @object GenInteractionClass SelectReplyBar ={
        GI_comp =   @SelectCancelTrigger,
                    @ConfigureDialog;

        HINT_MAKE_REPLY_BAR;
    }

    @object GenTriggerClass SelectCancelTrigger = {
        ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_DISMISS };

        HINT_SEEK_REPLY_BAR;
    }


    @object ConfigureDialogClass ConfigureDialog = {
        GI_visMoniker = "Configure";
        GI_comp =       @OpenWithGroup,
                        @ConfigureReplyBar;

        GII_visibility = GIV_DIALOG;
        GII_attrs = @default | GIA_MODAL;

        HINT_PLACE_MONIKER_ABOVE;
        HINT_ORIENT_CHILDREN_HORIZONTALLY;
        HINT_SEEK_REPLY_BAR;
        HINT_DEFAULT_DEFAULT_ACTION;
    }

    @object GenInteractionClass OpenWithGroup = {
        GI_visMoniker = "Select applications to use in the 'Open With' dialogue";
        GI_comp =	@AddAppSelector,
                    @AddAppTrigger,
                    @OpenWithAppListGroup;

        HINT_DRAW_IN_BOX;
        HINT_PLACE_MONIKER_ABOVE;
        HINT_ORIENT_CHILDREN_HORIZONTALLY;
        HINT_CENTER_CHILDREN_VERTICALLY;
    }

    @object GenFileSelectorClass AddAppSelector = {
        GFSI_attrs =           ((FSA_ALLOW_CHANGE_DIRS) & (~FSA_SHOW_FILES_DISABLED) & (~FSA_HAS_OPEN_DIR_BUTTON) & (~FSA_HAS_CHANGE_DIRECTORY_LIST))
                                | ((FSA_HAS_FILE_LIST) & (~FSA_SHOW_FIXED_DISKS_ONLY) & (~FSA_HAS_CLOSE_DIR_BUTTON) & (~FSA_HAS_DOCUMENT_BUTTON)& (~FSA_HAS_CHANGE_DRIVE_LIST))
                                | ((FSA_USE_VIRTUAL_ROOT));

        GFSI_fileCriteria =      ((FSFC_DIRS) & (~FSFC_NON_GEOS_FILES))
                                | ((FSFC_GEOS_EXECUTABLES) & (~FSFC_GEOS_NON_EXECUTABLES));

        ATTR_GEN_FILE_SELECTOR_VIRTUAL_ROOT = {SP_APPLICATION, ""};
        ATTR_GEN_PATH_DATA = {SP_APPLICATION, ""};
        HINT_FILE_SELECTOR_FILE_LIST_WIDTH = 33;
        HINT_FILE_SELECTOR_NUMBER_OF_FILES_TO_SHOW = 10;
    }

    @object GenTriggerClass AddAppTrigger = {
        GI_visMoniker = list { @addAppTriggerTextMoniker, @RightArrowSCMoniker };
        GTI_destination = @OpenWithAppList;
        GTI_actionMsg = MSG_ADD_APP;

        HINT_USE_ICON_TEXT_COMBINATION_MONIKER = {0, 7};
    }

    @object GenInteractionClass OpenWithAppListGroup = {
        GI_comp =   @OpenWithAppList,
                    @RemoveAppTrigger;

        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_CENTER_CHILDREN_HORIZONTALLY;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    }

    @object AppDynamicListClass OpenWithAppList = {
        GIGI_destination = (TO_SELF);
        GIGI_behaviorType = GIGBT_EXCLUSIVE;
        //GIGI_behaviorType = GIGBT_NON_EXCLUSIVE;
        GDLI_queryMsg = MSG_QUERY_APP_MONIKER;

        HINT_ITEM_GROUP_SCROLLABLE;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
        HINT_FIXED_SIZE = {SST_AVG_CHAR_WIDTHS | 33};

        /*
        HINT_FIXED_SIZE {
            SpecWidth <SST_AVG_CHAR_WIDTHS, 24>
            SpecHeight <SST_LINES_OF_TEXT, 3>
            word	3
        },
        */
        // ATTR_GEN_ITEM_GROUP_STATUS_MSG = (word )MSG_SL_STARTUP_PROGRAM_SELECTED;
    }

    @object GenTriggerClass RemoveAppTrigger = {
        GI_visMoniker = list { @removeAppTriggerTextMoniker, @LeftArrowSCMoniker };

        GTI_destination = @OpenWithAppList;
        GTI_actionMsg = MSG_REMOVE_APP;

        HINT_USE_ICON_TEXT_COMBINATION_MONIKER = {0, 7};
        HINT_CENTER_MONIKER;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    }

    @object GenInteractionClass ConfigureReplyBar ={
        GI_comp =   @ConfigureOkTrigger,
                    @ConfigureCancelTrigger;

        HINT_MAKE_REPLY_BAR;
    }

    @object GenTriggerClass ConfigureOkTrigger = {
        GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
        GTI_actionMsg = MSG_CLOSE_CONFIGURE_DIALOG;
        GTI_destination = @ConfigureDialog;

        HINT_SEEK_REPLY_BAR;
        ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_APPLY };
        HINT_DEFAULT_DEFAULT_ACTION;
    }

    @object GenTriggerClass ConfigureCancelTrigger = {
        ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_DISMISS };
        HINT_SEEK_REPLY_BAR;
    }


    @object GenTriggerClass SoftLauncherTempl = {
        GI_states = @default & ~GS_USABLE;

        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    }

@end DialogUI;


/**************************************************************
dgroup
**************************************************************/
//API Struct - MUST be global
FMToolStruct FMToolInfo[1] = {
    {
        @ToolNameMoniker, (FMTF_SELECTED_ONLY | FMTT_DIALOG), 1
    }
};

optr    appList = NullOptr;
#define TOOL_ICON_WIDTH         15
#define TOOL_ICON_HEIGHT        15
#define TOOL_ICON_FLAGS         ((VMSF_GSTRING) | (VMS_TOOL << VMSF_STYLE_OFFSET))


MemHandle    G_selFiles = NullHandle;


/**************************************************************
FileManager API Function - fetch Tools
**************************************************************/
//FMFetchToolsProc GetThoseTools
word _pascal _export GetThoseTools(FMToolStruct **tablePtr)
{
    *tablePtr = (FMToolStruct*) &FMToolInfo;
    return 1;
}

/**************************************************************
The user has clicked on our Utilities menu item: "Open With"
GeodeHandle filemgr => Process that is subclass of FileManagerClass
word toolNum =>	Entry # of activated tool within table returned by
                FMTF_FETCH_TOOLS
word entryNum
***************************************************************/
//FMToolProc OpenWithEntryPoint()
void _pascal _export OpenWithEntryPoint(
    GeodeHandle filemgr,
    word toolNum,
    word entryNum
)
{
    optr                        dialog = NullOptr;

    // fetch the GeoManager selection
    G_selFiles = @call ConstructOptr(filemgr, 0)::MSG_FM_GET_SELECTED_FILES();

    // check for non-DOS files, folders, etc. first
    if (CheckIfUnsupportedFiles()) // true on ERROR
    {
        UserStandardDialogOptr(
            0, 0, 0, 0,
            @errorNoDOSFile,
            ((CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
             (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET))
        );
        return;
    }

    // we assume just DOS files in the list as of now and bring up the dialogue
    dialog = @call ConstructOptr(filemgr, 0)::MSG_FM_DUP_AND_ADD(@SelectDialog, FMP_APPLICATION);
    @call dialog::MSG_GEN_SET_USABLE(VUM_NOW);
    (void) UserDoDialog(dialog);
    UserDestroyDialog(dialog);
}


/**************************************************************
check if unsupported file
**************************************************************/
Boolean CheckIfUnsupportedFiles()
{
    MemHandle                   curBlock;
    MemHandle                   nextBlock;
    FileQuickTransferHeader*    headerPtr;
    FileOperationInfoEntry*     entriesPtr;
    word                        i;
    Boolean                     hadError = FALSE;
    FileAttrs                   fAttrs;

    curBlock = G_selFiles;
    while (curBlock != 0)
    {
        headerPtr  = (FileQuickTransferHeader*) MemLock(curBlock); // get pointer to it header
        entriesPtr = (FileOperationInfoEntry*) (headerPtr + 1); // get pointer to first entry (follows header)

        for (i=0; i < headerPtr->FQTH_numFiles; i++)
        {
            if ((entriesPtr->FOIE_type == GFT_NOT_GEOS_FILE) &&
                (entriesPtr->FOIE_type != GFT_DIRECTORY))
            {
                // for folders above DOCUMENT/WORLD GFT_DIRECTORY seems not to be set (...?) -
                // so we check again if actually a folder
                FilePushDir();
                if (FileSetCurrentPath(headerPtr->FQTH_diskHandle, headerPtr->FQTH_pathname) != NullHandle)
                {
                    fAttrs = FileGetAttributes(entriesPtr->FOIE_name);
                    if ((fAttrs & FA_SUBDIR) ||
                        (fAttrs & FA_VOLUME) ||
                        (fAttrs & FA_SYSTEM) ||
                        (fAttrs & FA_HIDDEN) ||
                        (fAttrs & FA_RDONLY))
                    {
                        FilePopDir();
                        hadError = TRUE;
                        break;
                    }
                }
                else
                {
                    FilePopDir();
                    hadError = TRUE;
                    break;
                }
                FilePopDir();
            }
            else
            {
                hadError = TRUE;
                break;
            }

            // point to the next entry
            entriesPtr = (FileOperationInfoEntry*) entriesPtr + 1;
        }

        if (hadError)
        {
            MemUnlock(curBlock);
            break;
        }
        else
        {
            // get next block, if any
            nextBlock = headerPtr->FQTH_nextBlock; // returns 0 if end, which breaks the loop
            MemUnlock(curBlock);
            curBlock = nextBlock;
        }
    }

    return hadError;
}

/**************************************************************
is app on blacklist?
**************************************************************/
Boolean IsAppOnBlacklist(GeodeToken* appToken)
{
    word            numApps = 0;
    GeodeToken*     listApp = (void*) 0;
    word            size = 0;
    word            i = 0;
    Boolean         isOnList = FALSE;

    MemLock(HandleOf(@BlacklistArray));
    numApps = ChunkArrayGetCount(@BlacklistArray);

    for (i = 0; i < numApps; i++)
    {
        listApp = ChunkArrayElementToPtr(@BlacklistArray, i, &size);

        if ((appToken->GT_chars[0] == listApp->GT_chars[0]) &&
            (appToken->GT_chars[1] == listApp->GT_chars[1]) &&
            (appToken->GT_chars[2] == listApp->GT_chars[2]) &&
            (appToken->GT_chars[3] == listApp->GT_chars[3]) &&
            (appToken->GT_manufID  == listApp->GT_manufID))
        {
            isOnList = TRUE;
            break;
        }
    }

    MemUnlock(HandleOf(@BlacklistArray));

    return isOnList;
}

/**************************************************************
load files one by one
**************************************************************/
void LoadFiles(GeodeToken* token, char* pathnameAndFile)
{
    MemHandle                   curBlock;
    MemHandle                   nextBlock;
    FileQuickTransferHeader*    headerPtr;
    FileOperationInfoEntry*     entriesPtr;
    word                        i;

    curBlock = G_selFiles;

    FilePushDir();
    FileSetStandardPath(SP_APPLICATION);
    while (curBlock != 0)
    {
        headerPtr  = (FileQuickTransferHeader*) MemLock(curBlock); // get pointer to its header
        entriesPtr = (FileOperationInfoEntry*) (headerPtr + 1); // get pointer to first entry (follows header)

        for (i=0; i < headerPtr->FQTH_numFiles; i++)
        {
            LaunchApp(
                token,
                SP_APPLICATION,
                pathnameAndFile,
                headerPtr->FQTH_diskHandle,
                headerPtr->FQTH_pathname,
                entriesPtr->FOIE_name
            );

            // point to the next entry
            entriesPtr = (FileOperationInfoEntry*) entriesPtr + 1;
        }

        // get next block, if any
        nextBlock = headerPtr->FQTH_nextBlock; // returns 0 if end, which breaks the loop
        MemUnlock(curBlock);
        MemFree(curBlock);
        curBlock = nextBlock;
    }
    FilePopDir();
}

/**************************************************************
launch application with DOS file via IACP...
**************************************************************/
void LaunchApp(
    GeodeToken *appTok,
    DiskHandle appDisk,
    char *appPath,
    DiskHandle dataDisk,
    PathName *dataPath,
    FileLongName *dataFName)
{
    IACPConnection       iacpConnectionToken = IACP_NO_CONNECTION;
    word                 connectionFlags = IACPSM_USER_INTERACTIBLE | IACPCF_FIRST_ONLY;
    word                 serverCount;
    MemHandle            albBlock;
    AppLaunchBlock       *albPtr;

    albBlock = IACPCreateDefaultLaunchBlock(MSG_GEN_PROCESS_OPEN_APPLICATION);

    albPtr = MemLock(albBlock);
    strcpy(albPtr->ALB_appRef.AIR_fileName, appPath);
    albPtr->ALB_appRef.AIR_diskHandle = appDisk;
    albPtr->ALB_diskHandle = dataDisk;
    strcpy(albPtr->ALB_path, dataPath);
    strcpy(albPtr->ALB_dataFile, dataFName);
    MemUnlock(albBlock);

    iacpConnectionToken = IACPConnect(appTok, connectionFlags, albBlock, NullOptr, &serverCount);
    if(iacpConnectionToken != IACP_NO_CONNECTION)
    {
        IACPShutdown(iacpConnectionToken, NullOptr);
    }
}

/********************************************************************

********************************************************************/
Boolean checkIfInList(optr list, char* appName, word listLen)
{
    word    i = 0;
    char*   str = (char*) 0;
    word    elSize = 0;

    // list must be locked!
    for (i=0; i < listLen; i++)
    {
        str = (char*) ChunkArrayElementToPtr(list, i, &elSize);
        if (strstr(str, appName))
        {
            return TRUE;
        }
    }

    return FALSE;
}

/********************************************************************

********************************************************************/
void readAppsFromIniFile()
{
    MemHandle       mh = NullHandle;
    ChunkHandle     ch = NullChunk;
    optr            ourList = NullOptr;

    if (mh != NullHandle) MemFree(mh);
    mh = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    MemLock(mh);

    ch = ChunkArrayCreate(mh, sizeof(PathName) + sizeof(FileLongName), 0, 0);

    appList = ConstructOptr(mh, ch);
    ourList = appList;

    InitFileEnumStringSection(
        _TEXT("fileManager"),
        _TEXT("openWith"),
        IFRF_READ_ALL,
        ReadAppsCallback,
        (void*) &ourList);

    MemUnlock(mh);
}

/********************************************************************

********************************************************************/
Boolean ReadAppsCallback(const char *stringSection, word sectionNum, void* enumData)
{
    char* str;

    str = (char*) ChunkArrayAppend(*((optr*) enumData), 0); // convert VOID-Pointer to OPTR-Pointer and deref afterwards...
    strcpy(str, stringSection);

    return FALSE; // no error
}

/********************************************************************

********************************************************************/
void writeIniFile()
{
    word    i = 0;
    char*   str = (char*) 0;
    word    elSize = 0;
    word    listLen = 0;

    InitFileDeleteEntry(_TEXT("fileManager"), _TEXT("openWith"));

    MemLock(HandleOf(appList));
    listLen = ChunkArrayGetCount(appList);

    // list must be locked!
    for (i = 0; i < listLen; i++)
    {
        str = (char*) ChunkArrayElementToPtr(appList, i, &elSize);
            InitFileWriteStringSection(
            _TEXT("fileManager"),
            _TEXT("openWith"),
            str
        );
    }

    InitFileCommit();
    MemUnlock(HandleOf(appList));
}


/********************************************************************
Classes & Methods
********************************************************************/


/********************************************************************

********************************************************************/
@method OpenWithDialogClass, MSG_GEN_INTERACTION_INITIATE
{
    readAppsFromIniFile();
    @callsuper();
}

/********************************************************************

********************************************************************/
@method GeodeTokenTriggerClass, MSG_APP_TRIGGER_PRESSED
{
    GeodeToken                  token;
    char    	                pathnameAndFile[PATH_BUFFER_SIZE + FILE_LONGNAME_BUFFER_SIZE] = {0};   	/* Buffer for fetching the complete path of the application */

    @call trigger::MSG_META_GET_VAR_DATA(ATTR_GEODE_TOKEN_TO_PASS, sizeof(GeodeToken), &token);
    @call trigger::MSG_META_GET_VAR_DATA(ATTR_GEODE_FILE_NAME, sizeof(FileLongName), pathnameAndFile);

    // if (IsAppOnBlacklist(&token))
    // {
    //     UserStandardDialogOptr(
    //         0, 0, 0, 0,
    //         @errorNoCompatibleApp,
    //         ((CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
    //         (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET))
    //     );
    //     return;
    // }


    LoadFiles(&token, pathnameAndFile);

    @call @dup(@SelectDialog)::MSG_GEN_GUP_INTERACTION_COMMAND(IC_OK);
}


/********************************************************************

********************************************************************/
@method OpenWithContentClass, MSG_SPEC_BUILD
{
    @callsuper();

    @call oself::MSG_BUILD_TRIGGERS();
}


/********************************************************************

********************************************************************/
@method OpenWithContentClass, MSG_BUILD_TRIGGERS
{
    GeodeToken          tok;
    char*               filePtr = (void*) 0;
    byte                triggerNo = 0;
    word                num = 0;
    word                elSize = 0;
    optr                triggerObj = NullOptr;

    @call oself::MSG_REMOVE_ALL_APP_TRIGGERS();

    MemLock(HandleOf(appList));
    num = ChunkArrayGetCount(appList);

    if (num > 0)
    {
        for (triggerNo=0; triggerNo < num; triggerNo++)
        {
            FilePushDir();
            FileSetStandardPath(SP_APPLICATION);
            filePtr = (char*) ChunkArrayElementToPtr(appList, triggerNo, &elSize);
            FileGetPathExtAttributes(filePtr, FEA_TOKEN, (&tok), sizeof(GeodeToken));
            FilePopDir();

            triggerObj = addButton1(oself, &tok);

            // finally, set usable
            @call triggerObj::MSG_GEN_SET_USABLE(VUM_NOW);

            @call triggerObj::MSG_GEN_TRIGGER_SET_DESTINATION(triggerObj);
            @call triggerObj::MSG_GEN_TRIGGER_SET_ACTION_MSG(MSG_APP_TRIGGER_PRESSED);

            @call triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_TOKEN_TO_PASS & (~VDF_SAVE_TO_STATE)), sizeof(GeodeToken), &tok);
            @call triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_FILE_NAME & (~VDF_SAVE_TO_STATE)), strlen(filePtr), filePtr);

            @call triggerObj::MSG_META_ADD_VAR_DATA((HINT_EXPAND_WIDTH_TO_FIT_PARENT & (~VDF_SAVE_TO_STATE)), 0, 0);
        }
    }

    MemUnlock(HandleOf(appList));
}

optr addButton(optr parentObj, GeodeToken* tok)
{
    Boolean             isMoniker = FALSE;
    ChunkHandle         iconMoniker = NULL;
    ChunkHandle         textMoniker = NULL;
    optr                finalMoniker = NULL;
    word                chunkSize = NULL;
    DisplayScheme	    ds;
    optr                triggerObj = NullOptr;
    MemHandle           triggerBlock = NullHandle;

    triggerBlock = OptrToHandle(parentObj);
    triggerObj = ObjInstantiate(triggerBlock, (ClassStruct*)&GeodeTokenTriggerClass);
    triggerBlock = OptrToHandle(triggerObj);

    if (triggerObj != NullOptr)
    {
        @call parentObj::MSG_GEN_ADD_CHILD(triggerObj, CCO_LAST);

        @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&ds);

        ObjLockObjBlock(OptrToHandle(triggerObj));

        isMoniker = TokenLoadMonikerChunk(
            TOKEN_CHARS(tok->GT_chars[0],tok->GT_chars[1],tok->GT_chars[2],tok->GT_chars[3]),
            tok->GT_manufID,
            ds.DS_displayType,
            ((VMSF_GSTRING | VMSF_COPY_CHUNK) | (VMS_TOOL << VMSF_STYLE_OFFSET)),
            OptrToHandle(triggerObj),
            &chunkSize,
            &iconMoniker
        );

        isMoniker = TokenLoadMonikerChunk(
            TOKEN_CHARS(tok->GT_chars[0],tok->GT_chars[1],tok->GT_chars[2],tok->GT_chars[3]),
            tok->GT_manufID,
            ds.DS_displayType,
            (VMSF_COPY_CHUNK | (VMS_TEXT << VMSF_STYLE_OFFSET)),
            OptrToHandle(triggerObj),
            &chunkSize,
            &textMoniker
        );

        @send triggerObj::MSG_GEN_USE_VIS_MONIKER(iconMoniker, VUM_NOW);
        @send triggerObj::MSG_GEN_USE_VIS_MONIKER(textMoniker, VUM_NOW);

        if (iconMoniker && textMoniker)
        {

            ECLMemExists(ConstructOptr(OptrToHandle(triggerObj), textMoniker));
            ECLMemExists(ConstructOptr(OptrToHandle(triggerObj), iconMoniker));

            finalMoniker = UserCreateIconTextMoniker(
                ConstructOptr(OptrToHandle(triggerObj), textMoniker),
                ConstructOptr(OptrToHandle(triggerObj), iconMoniker),
                OptrToHandle(triggerObj),
                (word) 7,
                0
            );

            if (finalMoniker) @send triggerObj::MSG_GEN_USE_VIS_MONIKER(OptrToChunk(finalMoniker), VUM_NOW);
        }

        MemUnlock(OptrToHandle(triggerObj));

        return triggerObj;
    }

    return 0;
}

optr addButton1(optr parentObj, GeodeToken* tok)
{
    Boolean             isMoniker = FALSE;
    ChunkHandle         iconMoniker = NULL;
    ChunkHandle         textMoniker = NULL;
    optr                finalMoniker = NULL;
    word                chunkSize = NULL;
    DisplayScheme	    ds;
    optr                triggerObj = NullOptr;
    MemHandle           mhHeap = NullHandle;

    triggerObj = ObjInstantiate(OptrToHandle(parentObj), (ClassStruct*)&GeodeTokenTriggerClass);

    if (triggerObj != NullOptr)
    {
        mhHeap = MemAlloc(STD_INIT_HEAP, HF_DYNAMIC, HAF_STANDARD_LOCK);
        LMemInitHeap(
            mhHeap,
            LMEM_TYPE_GENERAL,
            0,
            sizeof(LMemBlockHeader),
            2,
            STD_INIT_HEAP
        );

        @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&ds);

        isMoniker = TokenLoadMonikerChunk(
            TOKEN_CHARS(tok->GT_chars[0],tok->GT_chars[1],tok->GT_chars[2],tok->GT_chars[3]),
            tok->GT_manufID,
            ds.DS_displayType,
            ((VMSF_GSTRING | VMSF_COPY_CHUNK) | (VMS_TOOL << VMSF_STYLE_OFFSET)),
            mhHeap,
            &chunkSize,
            &iconMoniker
        );

        isMoniker = TokenLoadMonikerChunk(
            TOKEN_CHARS(tok->GT_chars[0],tok->GT_chars[1],tok->GT_chars[2],tok->GT_chars[3]),
            tok->GT_manufID,
            ds.DS_displayType,
            (VMSF_COPY_CHUNK | (VMS_TEXT << VMSF_STYLE_OFFSET)),
            mhHeap,
            &chunkSize,
            &textMoniker
        );

        @send triggerObj::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(ConstructOptr(mhHeap, iconMoniker), VUM_NOW);
        // @send triggerObj::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(ConstructOptr(mhHeap, textMoniker), VUM_NOW);

        /*
        if (iconMoniker && textMoniker)
        {

            ECLMemExists(ConstructOptr(OptrToHandle(triggerObj), textMoniker));
            ECLMemExists(ConstructOptr(OptrToHandle(triggerObj), iconMoniker));

            finalMoniker = UserCreateIconTextMoniker(
                ConstructOptr(mhHeap, textMoniker),
                ConstructOptr(mhHeap, iconMoniker),
                mhHeap,
                (word) 7,
                0
            );

            if (finalMoniker) @send triggerObj::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(finalMoniker, VUM_NOW);
        }
        */

        @call parentObj::MSG_GEN_ADD_CHILD(triggerObj, CCO_LAST);

        MemUnlock(mhHeap);
        MemFree(mhHeap);
    }

    return triggerObj;
}



/*-------------------------------------------------------------------
remove all our triggers from SysTray
-------------------------------------------------------------------*/
@method OpenWithContentClass, MSG_REMOVE_ALL_APP_TRIGGERS
{
    optr    trigger = NullOptr;

    while(TRUE)
    {
        trigger = @call oself::MSG_GEN_FIND_CHILD_AT_POSITION(0);
        if (trigger == NullOptr) break;
        @call trigger::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
        @call oself::MSG_GEN_REMOVE_CHILD(trigger, CCF_MARK_DIRTY);
        @call trigger::MSG_META_OBJ_FREE();
    }
}

/********************************************************************

********************************************************************/
@method ConfigureDialogClass, MSG_GEN_INTERACTION_INITIATE
{
    word    num = 0;

    @callsuper();

    MemLock(HandleOf(appList));
    num = ChunkArrayGetCount(appList);
    MemUnlock(HandleOf(appList));

    @call @dup(@OpenWithAppList)::MSG_GEN_DYNAMIC_LIST_INITIALIZE(num);
    @call @dup(@OpenWithAppList)::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(TRUE);
}


/********************************************************************

********************************************************************/
@method ConfigureDialogClass, MSG_CLOSE_CONFIGURE_DIALOG
{
    writeIniFile();

    @call @dup(@SelectContent)::MSG_BUILD_TRIGGERS();
}


/********************************************************************
// (optr list, word item);
********************************************************************/
@method	AppDynamicListClass, MSG_QUERY_APP_MONIKER
{
    char*   str = (void*) 0;
    word    elSize = 0;

    MemLock(HandleOf(appList));
    str = (char*) ChunkArrayElementToPtr(appList, item, &elSize);
    @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, str);
    MemUnlock(HandleOf(appList));
}


/********************************************************************

********************************************************************/
@method	AppDynamicListClass, MSG_ADD_APP
{
    word        num = 0;
    char*       str = (char*) 0;
    dword       flagsAndDisk;
    char        pathnameAndFile[PATH_BUFFER_SIZE + FILE_LONGNAME_BUFFER_SIZE] = {0};   	/* Buffer for fetching the complete path of the application */

    flagsAndDisk = @call @dup(@AddAppSelector)::MSG_GEN_FILE_SELECTOR_GET_FULL_SELECTION_PATH(&pathnameAndFile);

    if (GFS_GET_ENTRY_TYPE(flagsAndDisk) == GFSET_FILE)
    {
        if (strlen(pathnameAndFile) > 0)
        {
            MemLock(HandleOf(appList));

            num = ChunkArrayGetCount(appList);
            if (checkIfInList(appList, pathnameAndFile, num) == FALSE)
            {
                str = (char*) ChunkArrayAppend(appList, 0);
                strcpy(str, pathnameAndFile);

                num = ChunkArrayGetCount(appList);
                @call oself::MSG_GEN_DYNAMIC_LIST_INITIALIZE(num);
                @call oself::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(TRUE);
            }

            MemUnlock(HandleOf(appList));
        }
    }
}

/********************************************************************

********************************************************************/
@method	AppDynamicListClass, MSG_REMOVE_APP
{
    word                        idx = 0;
    word                        num = 0;

	idx = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();

    MemLock(HandleOf(appList));

	ChunkArrayDeleteRange(appList, idx, 1);
    num = ChunkArrayGetCount(appList);
    @call oself::MSG_GEN_DYNAMIC_LIST_INITIALIZE(num);
    @call oself::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(TRUE);

    MemUnlock(HandleOf(appList));
}

void ShowStopper()
{
    return;
}
