@include <openwith.goh>

/***********************************************************************
Resourcen
***********************************************************************/
@start FMUI, data;

    @visMoniker ToolNameMoniker = "Open With";
    @chunk char errorNoDOSFile[] = "Please select DOS files only.";
    @chunk char errorNoCompatibleApp[] = "The selected application is not compatible with DOS files.";

    @chunkArray GeodeToken BlacklistArray = {
        { "PMGR" , 0 },
        { "BCAL" , 0 },
        { "CLK$" , 0 },
        { "DUMP" , 0 },
        { "PERF" , 0 }
    };

@end FMUI;


@start DialogUI, notDetachable;

    @include "Art/mkrRightArrowSC.goh"
    @include "Art/mkrLeftArrowSC.goh"
    @visMoniker addAppTriggerTextMoniker = "Add";
    @visMoniker removeAppTriggerTextMoniker = "Remove";

    @object OpenWithDialogClass SelectDialog = {
        GI_visMoniker = "Open With";
        GI_comp =   @SelectView,
                    @SelectReplyBar;
        GI_states = (@default & (~GS_USABLE));
        GII_visibility = GIV_DIALOG;
        GII_attrs = @default | GIA_INITIATED_VIA_USER_DO_DIALOG | GIA_MODAL;

        HINT_PLACE_MONIKER_ABOVE;
        HINT_ORIENT_CHILDREN_VERTICALLY;
    }

    @object GenViewClass SelectView = {
        GVI_content = @SelectContent;
        GVI_attrs = @default | GVA_GENERIC_CONTENTS | GVA_DRAG_SCROLLING | GVA_SAME_COLOR_AS_PARENT_WIN;
        GVI_horizAttrs = @default | GVDA_NO_SMALLER_THAN_CONTENT; // GVDA_NO_LARGER_THAN_CONTENT
        GVI_vertAttrs = @default | GVDA_SCROLLABLE;

        HINT_FIXED_SIZE = {
        	SST_PCT_OF_FIELD_WIDTH | PCT_25,
        	SST_PCT_OF_FIELD_HEIGHT | PCT_35,
	        0
        };

        HINT_VIEW_REMOVE_SCROLLERS_WHEN_NOT_SCROLLABLE;
        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    }

    @object OpenWithContentClass SelectContent = {
        GCI_attrs = @default | VCNA_SAME_WIDTH_AS_VIEW;
        GCI_genView = @SelectView;

        // HINT_CUSTOM_CHILD_SPACING = SST_PIXELS | 0;
        // HINT_MINIMIZE_CHILD_SPACING;
        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    }

    @object GenInteractionClass SelectReplyBar = {
        GI_comp =   @ConfigureDialog,
                    @SelectCancelTrigger;

        HINT_MAKE_REPLY_BAR;
    }

    @object ConfigureDialogClass ConfigureDialog = {
        GI_visMoniker = "Configure";
        GI_comp =       @OpenWithGroup,
                        @ConfigureReplyBar;

        GII_visibility = GIV_DIALOG;
        GII_attrs = @default | GIA_MODAL;

        HINT_PLACE_MONIKER_ABOVE;
        HINT_ORIENT_CHILDREN_HORIZONTALLY;
        HINT_SEEK_REPLY_BAR;
        HINT_DEFAULT_DEFAULT_ACTION;
    }

    @object GenTriggerClass SelectCancelTrigger = {
        ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_DISMISS };

        HINT_SEEK_REPLY_BAR;
    }

    @object GenInteractionClass OpenWithGroup = {
        GI_visMoniker = "Applications to use in the 'Open With' dialog";
        GI_comp =	@OpenWithAddAppGroup,
                    @OpenWithAppListGroup;

        HINT_DRAW_IN_BOX;
        HINT_PLACE_MONIKER_ABOVE;
        HINT_ORIENT_CHILDREN_HORIZONTALLY;
        HINT_CENTER_CHILDREN_VERTICALLY;
    }

    @object GenInteractionClass OpenWithAddAppGroup = {
        GI_comp =   @AddAppSelector,
                    @AddAppTrigger;

        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_CENTER_CHILDREN_HORIZONTALLY;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    }

    @object GenFileSelectorClass AddAppSelector = {
        GFSI_attrs =           ((FSA_ALLOW_CHANGE_DIRS) & (~FSA_SHOW_FILES_DISABLED) & (~FSA_HAS_OPEN_DIR_BUTTON) & (~FSA_HAS_CHANGE_DIRECTORY_LIST))
                                | ((FSA_HAS_FILE_LIST) & (~FSA_SHOW_FIXED_DISKS_ONLY) & (~FSA_HAS_CLOSE_DIR_BUTTON) & (~FSA_HAS_DOCUMENT_BUTTON)& (~FSA_HAS_CHANGE_DRIVE_LIST))
                                | ((FSA_USE_VIRTUAL_ROOT));

        GFSI_fileCriteria =      ((FSFC_DIRS) & (~FSFC_NON_GEOS_FILES))
                                | ((FSFC_GEOS_EXECUTABLES) & (~FSFC_GEOS_NON_EXECUTABLES));
        GFSI_destination = @ConfigureDialog;
        GFSI_notificationMsg = MSG_FILEBROW_SELECTOR_ACTION;

        ATTR_GEN_FILE_SELECTOR_VIRTUAL_ROOT = {SP_APPLICATION, ""};
        ATTR_GEN_PATH_DATA = {SP_APPLICATION, ""};
        HINT_FILE_SELECTOR_FILE_LIST_WIDTH = 33;
        HINT_FILE_SELECTOR_NUMBER_OF_FILES_TO_SHOW = 10;
    }

    @object GenTriggerClass AddAppTrigger = {
        GI_visMoniker = list { @addAppTriggerTextMoniker, @RightArrowSCMoniker };
        GTI_destination = @OpenWithAppList;
        GTI_actionMsg = MSG_ADD_APP;

        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
        HINT_CENTER_MONIKER;
        HINT_USE_ICON_TEXT_COMBINATION_MONIKER = {0, 7};
    }

    @object GenInteractionClass OpenWithAppListGroup = {
        GI_comp =   @OpenWithAppList,
                    @RemoveAppTrigger;

        HINT_ORIENT_CHILDREN_VERTICALLY;
        HINT_CENTER_CHILDREN_HORIZONTALLY;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    }

    @object ConfigureAppListClass OpenWithAppList = {
        GIGI_destination = @OpenWithAppList;
        GIGI_behaviorType = GIGBT_EXCLUSIVE;
        GDLI_queryMsg = MSG_QUERY_APP_MONIKER;
        ATTR_GEN_ITEM_GROUP_STATUS_MSG = MSG_APPLIST_SELECTION_CHANGED;

        HINT_ITEM_GROUP_SCROLLABLE;
        HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
        HINT_FIXED_SIZE = {SST_AVG_CHAR_WIDTHS | 33};
    }

    @object GenTriggerClass RemoveAppTrigger = {
        GI_visMoniker = list { @removeAppTriggerTextMoniker, @LeftArrowSCMoniker };

        GTI_destination = @OpenWithAppList;
        GTI_actionMsg = MSG_REMOVE_APP;

        HINT_USE_ICON_TEXT_COMBINATION_MONIKER = {0, 7};
        HINT_CENTER_MONIKER;
        HINT_EXPAND_WIDTH_TO_FIT_PARENT;
    }

    @object GenInteractionClass ConfigureReplyBar ={
        GI_comp =   @ConfigureOkTrigger,
                    @ConfigureCancelTrigger;

        HINT_MAKE_REPLY_BAR;
    }

    @object GenTriggerClass ConfigureOkTrigger = {
        GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
        GTI_actionMsg = MSG_CONFIRM_CONFIGURE_DIALOG;
        GTI_destination = @ConfigureDialog;

        HINT_SEEK_REPLY_BAR;
        ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_APPLY };
        HINT_DEFAULT_DEFAULT_ACTION;
    }

    @object GenTriggerClass ConfigureCancelTrigger = {
        ATTR_GEN_TRIGGER_INTERACTION_COMMAND = { IC_DISMISS };
        HINT_SEEK_REPLY_BAR;
    }

@end DialogUI;


/**************************************************************
dgroup
**************************************************************/
optr    appList                 = NullOptr;

#define TOOL_ICON_WIDTH         15
#define TOOL_ICON_HEIGHT        15

const char  iniCat[] = "fileManager";
const char  iniKey[] = "openWith";

MemHandle    G_selFiles = NullHandle;


/**************************************************************
FileManager API Function - fetch Tools
**************************************************************/
//API Struct - MUST be global
FMToolStruct FMToolInfo[1] = {
    {
        @ToolNameMoniker, (FMTF_SELECTED_ONLY | FMTT_DIALOG), 1
    }
};

//FMFetchToolsProc GetThoseTools
word _pascal _export GetThoseTools(FMToolStruct **tablePtr)
{
    *tablePtr = (FMToolStruct*) &FMToolInfo;
    return 1;
}

/**************************************************************
The user has clicked on our Utilities menu item: "Open With"
GeodeHandle filemgr => Process that is subclass of FileManagerClass
word toolNum =>	Entry # of activated tool within table returned by
                FMTF_FETCH_TOOLS
word entryNum
***************************************************************/
//FMToolProc OpenWithEntryPoint()
void _pascal _export OpenWithEntryPoint(
    GeodeHandle filemgr,
    word toolNum,
    word entryNum
)
{
    optr    dialog = NullOptr;

    // fetch the GeoManager selection
    G_selFiles = @call ConstructOptr(filemgr, 0)::MSG_FM_GET_SELECTED_FILES();

    // check for non-DOS files, folders, etc. first
    if (CheckIfUnsupportedFiles()) // true on ERROR
    {
        UserStandardDialogOptr(
            0, 0, 0, 0,
            @errorNoDOSFile,
            ((CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
             (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET))
        );
        return;
    }

    // we assume just DOS files in the list as of now
    ReadAppsFromIniFile();

    dialog = @call ConstructOptr(filemgr, 0)::MSG_FM_DUP_AND_ADD(@SelectDialog, FMP_APPLICATION);
    @call dialog::MSG_GEN_SET_USABLE(VUM_NOW);
    (void) UserDoDialog(dialog);
    UserDestroyDialog(dialog);

    MemFree(OptrToHandle(appList));
}


/**************************************************************
check if unsupported file
**************************************************************/
Boolean CheckIfUnsupportedFiles()
{
    MemHandle                   curBlock;
    MemHandle                   nextBlock;
    FileQuickTransferHeader*    headerPtr;
    FileOperationInfoEntry*     entriesPtr;
    word                        i;
    Boolean                     hadError = FALSE;
    FileAttrs                   fAttrs;

    curBlock = G_selFiles;
    while (curBlock != 0)
    {
        headerPtr  = (FileQuickTransferHeader*) MemLock(curBlock); // get pointer to its header
        entriesPtr = (FileOperationInfoEntry*) (headerPtr + 1); // get pointer to first entry (follows header)

        for (i=0; i < headerPtr->FQTH_numFiles; i++)
        {
            if ((entriesPtr->FOIE_type == GFT_NOT_GEOS_FILE) &&
                (entriesPtr->FOIE_type != GFT_DIRECTORY))
            {
                // for folders above DOCUMENT/WORLD GFT_DIRECTORY seems not to be set (...?) -
                // so we check again if actually a folder
                FilePushDir();
                if (FileSetCurrentPath(headerPtr->FQTH_diskHandle, headerPtr->FQTH_pathname) != NullHandle)
                {
                    fAttrs = FileGetAttributes(entriesPtr->FOIE_name);
                    if ((fAttrs & FA_SUBDIR) ||
                        (fAttrs & FA_VOLUME) ||
                        (fAttrs & FA_SYSTEM) ||
                        (fAttrs & FA_HIDDEN) ||
                        (fAttrs & FA_RDONLY))
                    {
                        FilePopDir();
                        hadError = TRUE;
                        break;
                    }
                }
                else
                {
                    FilePopDir();
                    hadError = TRUE;
                    break;
                }
                FilePopDir();
            }
            else
            {
                hadError = TRUE;
                break;
            }

            // point to the next entry
            entriesPtr = (FileOperationInfoEntry*) entriesPtr + 1;
        }

        if (hadError)
        {
            MemUnlock(curBlock);
            break;
        }
        else
        {
            // get next block, if any
            nextBlock = headerPtr->FQTH_nextBlock; // returns 0 if end, which breaks the loop
            MemUnlock(curBlock);
            curBlock = nextBlock;
        }
    }

    return hadError;
}

/**************************************************************
is app on blacklist - currently not active
    if (IsAppOnBlacklist(&token))
    {
        UserStandardDialogOptr(
            0, 0, 0, 0,
            @errorNoCompatibleApp,
            ((CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
            (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET))
        );
        return;
    }
**************************************************************/
Boolean IsAppOnBlacklist(GeodeToken* appToken)
{
    word            numApps = 0;
    GeodeToken*     listApp = (void*) 0;
    word            size = 0;
    word            i = 0;
    Boolean         isOnList = FALSE;

    MemLock(HandleOf(@BlacklistArray));
    numApps = ChunkArrayGetCount(@BlacklistArray);

    for (i = 0; i < numApps; i++)
    {
        listApp = ChunkArrayElementToPtr(@BlacklistArray, i, &size);

        if ((appToken->GT_chars[0] == listApp->GT_chars[0]) &&
            (appToken->GT_chars[1] == listApp->GT_chars[1]) &&
            (appToken->GT_chars[2] == listApp->GT_chars[2]) &&
            (appToken->GT_chars[3] == listApp->GT_chars[3]) &&
            (appToken->GT_manufID  == listApp->GT_manufID))
        {
            isOnList = TRUE;
            break;
        }
    }

    MemUnlock(HandleOf(@BlacklistArray));

    return isOnList;
}

/**************************************************************
load files one by one
**************************************************************/
void LoadFiles(GeodeToken* token, char* pathnameAndFile)
{
    MemHandle                   curBlock;
    MemHandle                   nextBlock;
    FileQuickTransferHeader*    headerPtr;
    FileOperationInfoEntry*     entriesPtr;
    word                        i;

    curBlock = G_selFiles;

    FilePushDir();
    FileSetStandardPath(SP_APPLICATION);
    while (curBlock != 0)
    {
        headerPtr  = (FileQuickTransferHeader*) MemLock(curBlock); // get pointer to its header
        entriesPtr = (FileOperationInfoEntry*) (headerPtr + 1); // get pointer to first entry (follows header)

        for (i=0; i < headerPtr->FQTH_numFiles; i++)
        {
            LaunchApp(
                token,
                SP_APPLICATION,
                pathnameAndFile,
                headerPtr->FQTH_diskHandle,
                headerPtr->FQTH_pathname,
                entriesPtr->FOIE_name
            );

            // point to the next entry
            entriesPtr = (FileOperationInfoEntry*) entriesPtr + 1;
        }

        // get next block, if any
        nextBlock = headerPtr->FQTH_nextBlock; // returns 0 if end, which breaks the loop
        MemUnlock(curBlock);
        MemFree(curBlock);
        curBlock = nextBlock;
    }
    FilePopDir();
}

/**************************************************************
launch application with DOS file via IACP...
**************************************************************/
void LaunchApp(
    GeodeToken *appTok,
    DiskHandle appDisk,
    char *appPath,
    DiskHandle dataDisk,
    PathName *dataPath,
    FileLongName *dataFName
)
{
    IACPConnection       iacpConnectionToken = IACP_NO_CONNECTION;
    word                 connectionFlags = IACPSM_USER_INTERACTIBLE | IACPCF_FIRST_ONLY;
    word                 serverCount;
    MemHandle            albBlock;
    AppLaunchBlock       *albPtr;

    albBlock = IACPCreateDefaultLaunchBlock(MSG_GEN_PROCESS_OPEN_APPLICATION);

    albPtr = MemLock(albBlock);
    strcpy(albPtr->ALB_appRef.AIR_fileName, appPath);
    albPtr->ALB_appRef.AIR_diskHandle = appDisk;
    albPtr->ALB_diskHandle = dataDisk;
    strcpy(albPtr->ALB_path, dataPath);
    strcpy(albPtr->ALB_dataFile, dataFName);
    MemUnlock(albBlock);

    iacpConnectionToken = IACPConnect(appTok, connectionFlags, albBlock, NullOptr, &serverCount);
    if(iacpConnectionToken != IACP_NO_CONNECTION)
    {
        IACPShutdown(iacpConnectionToken, NullOptr);
    }
}

/********************************************************************

********************************************************************/
Boolean checkIfInList(optr list, char* appName, word listLen)
{
    word    i = 0;
    char*   str = (char*) 0;
    word    elSize = 0;

    // list must be locked!
    for (i=0; i < listLen; i++)
    {
        str = (char*) ChunkArrayElementToPtr(list, i, &elSize);
        if (strstr(str, appName))
        {
            return TRUE;
        }
    }

    return FALSE;
}

/********************************************************************

********************************************************************/
void ReadAppsFromIniFile()
{
    MemHandle       mh = NullHandle;
    ChunkHandle     ch = NullChunk;
    optr            ourList = NullOptr;

    if (mh != NullHandle) MemFree(mh);
    mh = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    MemLock(mh);

    ch = ChunkArrayCreate(mh, sizeof(PathName) + sizeof(FileLongName), 0, 0);

    appList = ConstructOptr(mh, ch);
    ourList = appList;

    InitFileEnumStringSection(
        iniCat,
        iniKey,
        IFRF_READ_ALL,
        ReadAppsCallback,
        (void*) &ourList);

    MemUnlock(mh);
}

/********************************************************************

********************************************************************/
Boolean ReadAppsCallback(const char *stringSection, word sectionNum, void* enumData)
{
    char* str;

    str = (char*) ChunkArrayAppend(*((optr*) enumData), 0); // convert VOID-Pointer to OPTR-Pointer and deref afterwards...
    strcpy(str, stringSection);

    return FALSE; // no error
}

/********************************************************************

********************************************************************/
void WriteAppsToIniFile()
{
    word    i = 0;
    char*   str = (char*) 0;
    word    elSize = 0;
    word    listLen = 0;

    InitFileDeleteEntry(iniCat, iniKey);

    MemLock(HandleOf(appList));
    listLen = ChunkArrayGetCount(appList);

    // list must be locked!
    for (i = 0; i < listLen; i++)
    {
        str = (char*) ChunkArrayElementToPtr(appList, i, &elSize);
            InitFileWriteStringSection(
            iniCat,
            iniKey,
            str
        );
    }

    InitFileCommit();
    MemUnlock(HandleOf(appList));
}


/********************************************************************
Classes & Methods
********************************************************************/

/********************************************************************

********************************************************************/
@method OpenWithDialogClass, MSG_APP_TRIGGER_PRESSED
{
    GeodeToken        token;
    char    	      pathnameAndFile[PATH_BUFFER_SIZE + FILE_LONGNAME_BUFFER_SIZE] = {0};

    @call trigger::MSG_META_GET_VAR_DATA(ATTR_GEODE_TOKEN_TO_PASS, sizeof(GeodeToken), &token);
    @call trigger::MSG_META_GET_VAR_DATA(ATTR_GEODE_FILE_NAME, sizeof(FileLongName), pathnameAndFile);

    LoadFiles(&token, pathnameAndFile);

    @call oself::MSG_GEN_GUP_INTERACTION_COMMAND(IC_OK);
}


/********************************************************************

********************************************************************/
@method OpenWithDialogClass, MSG_GEN_INTERACTION_INITIATE
{
    @callsuper();

    @call @dup(@SelectContent)::MSG_BUILD_TRIGGERS();
}


/********************************************************************

********************************************************************/
@method OpenWithContentClass, MSG_BUILD_TRIGGERS
{
    GeodeToken          tok;
    char*               filePtr = (char*) 0;
    byte                triggerNo = 0;
    word                num = 0;
    word                elSize = 0;
    optr                triggerObj = NullOptr;
    char*               fname = (char*) 0;

    @call oself::MSG_REMOVE_ALL_APP_TRIGGERS();

    MemLock(HandleOf(appList));
    num = ChunkArrayGetCount(appList);

    if (num > 0)
    {
        for (triggerNo=0; triggerNo < num; triggerNo++)
        {
            FilePushDir();
            FileSetStandardPath(SP_APPLICATION);
            filePtr = (char*) ChunkArrayElementToPtr(appList, triggerNo, &elSize);
            FileGetPathExtAttributes(filePtr, FEA_TOKEN, (&tok), sizeof(GeodeToken));
            fname = strrchr(filePtr, '\\')+1;
            FilePopDir();

            triggerObj = ObjInstantiate(OptrToHandle(oself), (ClassStruct*) &OpenWithAppLaunchTriggerClass);
            @send oself::MSG_GEN_ADD_CHILD(triggerObj, CCO_LAST);

            @send triggerObj::MSG_SET_TRIGGER_MONIKER(&tok, fname);
            @send triggerObj::MSG_GEN_TRIGGER_SET_DESTINATION(@dup(@SelectDialog));
            @send triggerObj::MSG_GEN_TRIGGER_SET_ACTION_MSG(MSG_APP_TRIGGER_PRESSED);
            @send triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_TOKEN_TO_PASS & (~VDF_SAVE_TO_STATE)), sizeof(GeodeToken), &tok);
            @send triggerObj::MSG_META_ADD_VAR_DATA((ATTR_GEODE_FILE_NAME & (~VDF_SAVE_TO_STATE)), strlen(filePtr), filePtr);
            @send triggerObj::MSG_META_ADD_VAR_DATA((HINT_EXPAND_WIDTH_TO_FIT_PARENT & (~VDF_SAVE_TO_STATE)), 0, 0);
            @send triggerObj::MSG_GEN_SET_USABLE(VUM_NOW);
        }
    }

    MemUnlock(HandleOf(appList));
}

/*
@method OpenWithAppLaunchTriggerClass, MSG_SET_TRIGGER_MONIKER
{
    Boolean             isMoniker = FALSE;
    ChunkHandle         iconMoniker = NULL;
    ChunkHandle         textMoniker = NULL;
    optr                finalMoniker = NULL;
    word                chunkSize = NULL;
    DisplayScheme	    ds;
    MemHandle           mhHeap = NullHandle;

    mhHeap = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
    MemLock(mhHeap);

    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&ds);

    isMoniker = TokenLoadMonikerChunk(
        TOKEN_CHARS(tok->GT_chars[0],tok->GT_chars[1],tok->GT_chars[2],tok->GT_chars[3]),
        tok->GT_manufID,
        ds.DS_displayType,
        ((VMSF_GSTRING | VMSF_COPY_CHUNK) | (VMS_TOOL << VMSF_STYLE_OFFSET)),
        mhHeap,
        &chunkSize,
        &iconMoniker
    );

    isMoniker = TokenLoadMonikerChunk(
        TOKEN_CHARS(tok->GT_chars[0],tok->GT_chars[1],tok->GT_chars[2],tok->GT_chars[3]),
        tok->GT_manufID,
        ds.DS_displayType,
        (VMSF_COPY_CHUNK | (VMS_TEXT << VMSF_STYLE_OFFSET)),
        mhHeap,
        &chunkSize,
        &textMoniker
    );

    // @send oself::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(ConstructOptr(mhHeap, iconMoniker), VUM_NOW);
    // @send oself::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(ConstructOptr(mhHeap, textMoniker), VUM_NOW);

    if (iconMoniker && textMoniker)
    {
        ECLMemExists(ConstructOptr(OptrToHandle(oself), textMoniker));
        ECLMemExists(ConstructOptr(OptrToHandle(oself), iconMoniker));

        finalMoniker = UserCreateIconTextMoniker(
            ConstructOptr(mhHeap, textMoniker),
            ConstructOptr(mhHeap, iconMoniker),
            mhHeap,
            (word) 11,
            0
        );

        if (finalMoniker) @send oself::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(finalMoniker, VUM_NOW);
    }

    MemUnlock(mhHeap);
    MemFree(mhHeap);
}
*/

@method OpenWithAppLaunchTriggerClass, MSG_SET_TRIGGER_MONIKER
{
    Boolean                 isMoniker = FALSE;
    DisplayScheme	        ds;
    MemHandle               mhHeap = NullHandle;
    VisMoniker*             vmp;
    byte                    *moniker;
    byte*                   gstr = (void*) 0;
    word                    foo = 0;
    TokenMonikerInfo        tmi;
    GStateHandle            gs, mgs;
    word                    gschunk;

    @call oself::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(fname, VUM_DELAYED_VIA_APP_QUEUE);

    @call GeodeGetAppObject(0)::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&ds);
    isMoniker = TokenLookupMoniker(
        TOKEN_CHARS(tok->GT_chars[0],tok->GT_chars[1],tok->GT_chars[2],tok->GT_chars[3]),
        tok->GT_manufID,
        ds.DS_displayType,
        ((VMSF_GSTRING) | (VMS_TOOL << VMSF_STYLE_OFFSET)),
        &tmi
    );

    if (isMoniker)
    {
        moniker = TokenLockTokenMoniker(tmi);
        vmp = LMemDeref((optr) moniker);

        if (vmp->VM_width <= TOOL_ICON_WIDTH)
        {
            // prepare "Canvas", GState for drawing
            mhHeap = MemAllocLMem(LMEM_TYPE_GSTRING, sizeof(LMemBlockHeader));
            MemLock(mhHeap);
            gs = GrCreateGString(mhHeap, GST_CHUNK, &gschunk);

            // load icon moniker from Token-DB, draw on canvas
            gstr = (byte *)vmp+(sizeof(VisMonikerWithGString));
            mgs = GrLoadGString(PtrToSegment(gstr), GST_PTR, PtrToOffset(gstr));
            GrSaveState(gs);
            GrDrawGString(gs, mgs, 0, 1, 0, &foo);
            GrRestoreState(gs);
            GrDestroyGString(mgs, gs, GSKT_LEAVE_DATA);

            // draw text
            GrDrawText(gs, TOOL_ICON_WIDTH + 2, 1, fname, 0);

            // finish
            GrEndGString(gs);

            // replace moniker
            @call oself::MSG_GEN_REPLACE_VIS_MONIKER(
                VUM_NOW,
                0, 0, 0,
                VMDT_GSTRING,
                VMST_OPTR,
            	(dword) ConstructOptr(mhHeap, gschunk)
            );

            // kill everything
            GrDestroyGString(gs, 0, GSKT_KILL_DATA);
            MemUnlock(mhHeap);
            MemFree(mhHeap);
        }

        TokenUnlockTokenMoniker(moniker);
    }
}


/*-------------------------------------------------------------------
remove all our triggers from SysTray
-------------------------------------------------------------------*/
@method OpenWithContentClass, MSG_REMOVE_ALL_APP_TRIGGERS
{
    optr    trigger = NullOptr;

    while(TRUE)
    {
        trigger = @call oself::MSG_GEN_FIND_CHILD_AT_POSITION(0);
        if (trigger == NullOptr) break;
        @call trigger::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
        @call oself::MSG_GEN_REMOVE_CHILD(trigger, CCF_MARK_DIRTY);
        @call trigger::MSG_META_OBJ_FREE();
    }
}

/********************************************************************

********************************************************************/
@method ConfigureDialogClass, MSG_GEN_INTERACTION_INITIATE
{
    word    num = 0;

    @callsuper();

    MemLock(HandleOf(appList));
    num = ChunkArrayGetCount(appList);
    MemUnlock(HandleOf(appList));

    @call @dup(@OpenWithAppList)::MSG_GEN_DYNAMIC_LIST_INITIALIZE(num);
    @call @dup(@OpenWithAppList)::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(TRUE);
    @call @dup(@RemoveAppTrigger)::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
}


/********************************************************************

********************************************************************/
@method ConfigureDialogClass, MSG_CONFIRM_CONFIGURE_DIALOG
{
    WriteAppsToIniFile();

    @call @dup(@SelectContent)::MSG_BUILD_TRIGGERS();
}

/********************************************************************

********************************************************************/
@method ConfigureDialogClass, MSG_FILEBROW_SELECTOR_ACTION
{
    word        num = 0;
    char        pathnameAndFile[PATH_BUFFER_SIZE + FILE_LONGNAME_BUFFER_SIZE] = {0};   	/* Buffer for fetching the complete path of the application */

    if (GFS_GET_ENTRY_TYPE(entryFlags) == GFSET_FILE)
    {
        (void) @call @dup(@AddAppSelector)::MSG_GEN_FILE_SELECTOR_GET_FULL_SELECTION_PATH(pathnameAndFile);

        MemLock(HandleOf(appList));
        num = ChunkArrayGetCount(appList);
        if (checkIfInList(appList, pathnameAndFile, num) == FALSE)
        {
            @call @dup(@AddAppTrigger)::MSG_GEN_SET_ENABLED(VUM_NOW);
        }
        else
        {
            @call @dup(@AddAppTrigger)::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
        }
        MemUnlock(HandleOf(appList));
    }
    else
    {
        @call @dup(@AddAppTrigger)::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    }
}

/********************************************************************
three arguments:
    selection (the contents of GIGI_selection)
    numSelections (the contents of GIGI_numSelections)
    stateFlags (the contents of GIGI_stateFlags)
********************************************************************/
@method	ConfigureAppListClass, MSG_APPLIST_SELECTION_CHANGED
{
    if (selection != GIGS_NONE)
    {
        @call @dup(@RemoveAppTrigger)::MSG_GEN_SET_ENABLED(VUM_NOW);
    }
}


/********************************************************************
// (optr list, word item);
********************************************************************/
@method	ConfigureAppListClass, MSG_QUERY_APP_MONIKER
{
    char*   filePtr = (void*) 0;
    word    elSize = 0;
    char*   fname = (char*) 0;

    MemLock(HandleOf(appList));

    filePtr = (char*) ChunkArrayElementToPtr(appList, item, &elSize);
    fname = strrchr(filePtr, '\\') + 1;
    @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, fname);

    MemUnlock(HandleOf(appList));
}


/********************************************************************

********************************************************************/
@method	ConfigureAppListClass, MSG_ADD_APP
{
    word        num = 0;
    char*       str = (char*) 0;
    dword       flagsAndDisk;
    char        pathnameAndFile[PATH_BUFFER_SIZE + FILE_LONGNAME_BUFFER_SIZE] = {0};   	/* Buffer for fetching the complete path of the application */

    flagsAndDisk = @call @dup(@AddAppSelector)::MSG_GEN_FILE_SELECTOR_GET_FULL_SELECTION_PATH(pathnameAndFile);

    if (GFS_GET_ENTRY_TYPE(flagsAndDisk) == GFSET_FILE)
    {
        if (strlen(pathnameAndFile) > 0)
        {
            MemLock(HandleOf(appList));

            num = ChunkArrayGetCount(appList);
            if (checkIfInList(appList, pathnameAndFile, num) == FALSE)
            {
                str = (char*) ChunkArrayAppend(appList, 0);
                strcpy(str, pathnameAndFile);

                num = ChunkArrayGetCount(appList);
                @call oself::MSG_GEN_DYNAMIC_LIST_INITIALIZE(num);
                @call oself::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(TRUE);
                @call @dup(@RemoveAppTrigger)::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
                @call @dup(@AddAppTrigger)::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
            }

            MemUnlock(HandleOf(appList));
        }
    }
}

/********************************************************************

********************************************************************/
@method	ConfigureAppListClass, MSG_REMOVE_APP
{
    word                        idx = 0;
    word                        num = 0;

	idx = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();

    MemLock(HandleOf(appList));

	ChunkArrayDeleteRange(appList, idx, 1);
    num = ChunkArrayGetCount(appList);
    @call oself::MSG_GEN_DYNAMIC_LIST_INITIALIZE(num);
    @call oself::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(TRUE);
    @call @dup(@RemoveAppTrigger)::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

    MemUnlock(HandleOf(appList));
}

void ShowStopper()
{
    return;
}
